<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Webrtc</title>
    <link href="/2020/09/10/Webrtc/"/>
    <url>/2020/09/10/Webrtc/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 框架梳理</p><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><a href="../WebrtcBase">WebrtcBase:基础内容</a></p><ul><li>sdp</li><li>code</li></ul><p><a href="../WebrtcStats">WebrtcStats:数据采集相关</a></p><ul><li>callstack</li></ul><p><a href="../WebrtcCall">WebrtcCall:会话控制管理</a></p><ul><li>callstack</li></ul><p><a href="../WebrtcVideo">WebrtcVideo:视频相关</a></p><ul><li>send recv</li><li>jitterbuffer</li></ul><p><a href="../WebrtcRateControl">WebrtcRateControl:流控</a></p><ul><li>layer</li><li>callstack</li></ul><p><a href="../WebrtcNetwork">WebrtcNetwork:抗弱网相关</a></p><ul><li>layer</li><li>callstack</li></ul><p><a href="../WebrtcBwe">WebrtcBwe:带宽预估相关</a></p><ul><li>layer</li><li>callstack</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>webrtc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webrtc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcBase</title>
    <link href="/2020/09/10/WebrtcBase/"/>
    <url>/2020/09/10/WebrtcBase/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 基础内容以及音视频相关整理</p><a id="more"></a><h1 id="WebrtcBase"><a href="#WebrtcBase" class="headerlink" title="WebrtcBase"></a>WebrtcBase</h1><h2 id="WebrtcCode"><a href="#WebrtcCode" class="headerlink" title="WebrtcCode"></a>WebrtcCode</h2><h3 id="序列号判断"><a href="#序列号判断" class="headerlink" title="序列号判断"></a>序列号判断</h3><pre><code class="c++">// 如果seq2 比seq1 要老的话，返回真// 1 2 3 4 5 6 7 8 // seq1 = 6 seq2 = 4 返回真bool AheadOf(uint16_t seq1, uint16_t seq2);</code></pre><h2 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h2><h3 id="SDP-中的流媒体"><a href="#SDP-中的流媒体" class="headerlink" title="SDP 中的流媒体"></a>SDP 中的流媒体</h3><h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><h5 id="H264"><a href="#H264" class="headerlink" title="H264"></a>H264</h5><p>h264 有四种级别的画质，分别是baseline、extended、main 和high。</p><ul><li>baseline 基本画质，支持I/P 帧</li><li>extended 进阶画质，支持I/P/B/SP/SI 帧(后两个没听说过) </li><li>main     主流画质，支持I/P/B 帧</li><li>high     高级画质</li></ul><p>webrtc 在sdp 交换中有对视频描述如下：</p><pre><code class="shell">a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001fa=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001fa=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01fa=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01fa=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d0032a=fmtp:123 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032</code></pre><p>其中profile-level-id=xxxxxx 就是H264 profile和level 的组合，xxxxxx 可以分为三部分，每部分为两个十六进制的数字，从左到右依次为profile_idc(表示画质)、profile_iop和level_idc(码率和分辨率限制)。一般关注第一个和第三个。</p><p><a href="https://blog.csdn.net/liang12360640/article/details/52096499" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/52096499</a></p><h3 id="SDP-中的setup"><a href="#SDP-中的setup" class="headerlink" title="SDP 中的setup"></a>SDP 中的setup</h3><p>a=setup 主要是表示dtls 协商中角色的问题，谁是客户端，谁是服务器。</p><pre><code class="shell"># 既可以是服务端 也可以是客户端a=setup:actpass# 客户端a=setup:active# 服务端a=setup:passive</code></pre><p><a href="https://blog.csdn.net/glw0223/article/details/91871718" target="_blank" rel="noopener">https://blog.csdn.net/glw0223/article/details/91871718</a><br><a href="https://blog.csdn.net/m0_37263637/article/details/96355737" target="_blank" rel="noopener">https://blog.csdn.net/m0_37263637/article/details/96355737</a></p><h3 id="SDP-中的-trickle"><a href="#SDP-中的-trickle" class="headerlink" title="SDP 中的 trickle"></a>SDP 中的 trickle</h3><pre><code class="shell">#通知对端支持trickle，即sdp里面描述媒体信息和ice候选项的信息可以分开传输a=ice-options:trickle</code></pre><p><a href="https://www.jianshu.com/p/61e3c9e13456" target="_blank" rel="noopener">https://www.jianshu.com/p/61e3c9e13456</a></p><h3 id="SDP-中的-音视频描述"><a href="#SDP-中的-音视频描述" class="headerlink" title="SDP 中的 音视频描述"></a>SDP 中的 音视频描述</h3><pre><code class="shell">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116</code></pre><p>AVP     ==&gt; audio video profile 不会启用rtcp 反馈，也不会根据rtcp反馈动态调整码率<br>AVPF    ==&gt; audio video profile feedback<br>SAVPF   ==&gt; safe audio video profile feedback</p><p><a href="https://segmentfault.com/a/1190000020794391" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020794391</a></p><h3 id="SDP-的格式"><a href="#SDP-的格式" class="headerlink" title="SDP 的格式"></a>SDP 的格式</h3><p>webrtc 中，unified plan、plan B、plan A 是SDP 中多路媒体略的协商方式，在72 版本中，Chrome 默认使用unified plan 替换了Plan B。<br>在浏览器端，打开chrome://webrtc-internals 可以查看到PeerConnection 使用的sdp 协商方式。</p><pre><code class="txt">https://webrtc.github.io/samples/src/content/peerconnection/pc1/, { iceServers: [], iceTransportPolicy: all, bundlePolicy: balanced, rtcpMuxPolicy: require, iceCandidatePoolSize: 0, sdpSemantics: &quot;unified-plan&quot; },</code></pre><ul><li>plan B : sdp 中，一个m 行描述多路media stream 以，msid 作为区分<pre><code class="shell">a=group:BUNDLE audioa=msid-semantic: WMS stream-id-2 stream-id-1m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:audio...a=rtpmap:103 ISAC/16000...a=ssrc:10 cname:cnamea=ssrc:10 msid:stream-id-1 track-id-1a=ssrc:10 mslabel:stream-id-1a=ssrc:10 label:track-id-1a=ssrc:11 cname:cnamea=ssrc:11 msid:stream-id-2 track-id-2a=ssrc:11 mslabel:stream-id-2a=ssrc:11 label:track-id-2</code></pre></li><li>unified plan: 一个m 行对弈一个media stream<pre><code class="shell">a=group:BUNDLE 0 1a=msid-semantic: WMSm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:0...a=sendrecva=msid:- &lt;track-id-1&gt;...a=rtpmap:103 ISAC/16000...a=ssrc:10 cname:cnamea=ssrc:10 msid: track-id-1a=ssrc:10 mslabel:a=ssrc:10 label:track-id-1m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:1...a=sendrecva=msid:- track-id-2...a=rtpmap:103 ISAC/16000...a=ssrc:11 cname:cnamea=ssrc:11 msid: track-id-2a=ssrc:11 mslabel:a=ssrc:11 label:track-id-2</code></pre></li></ul><p><a href="https://juejin.im/post/6844903792001974280" target="_blank" rel="noopener">https://juejin.im/post/6844903792001974280</a></p><h2 id="H264-1"><a href="#H264-1" class="headerlink" title="H264"></a>H264</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>H264 中，句法元素从大到小被组织为序列(GOP)、图像、切片、宏块、子宏块共五个层次。</p><p>一个序列 = n 个图像帧<br>一个帧 = n 个切片<br>一个切片 = n 个宏块<br>一个宏块 = n 个子宏块  </p><h3 id="码流结构"><a href="#码流结构" class="headerlink" title="码流结构"></a>码流结构</h3><p>码流结构从功能上分为两层：</p><ul><li>VCL(视频编码层)<br>  包括核心压缩引擎和快，宏块和片的语法级别定义，设计目标是尽可能独立于网络进行高效的编码。即编码处理的输出，表示被压缩编码后的视频数据序列</li><li>NAL(网络提取层)<br>  负责将VCL 产生的比特字符串适配到各种各样的网络和多元环境中，覆盖所有片级以上的语法级别</li></ul><p><img src="./media_foramt.png" srcset="/img/loading.gif" alt="media_format"></p><h3 id="NALU-HEADER"><a href="#NALU-HEADER" class="headerlink" title="NALU HEADER"></a>NALU HEADER</h3><pre><code class="txt">+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|   Type  |+---------------+</code></pre><p>NALU HEADER 数据位描述：</p><ul><li>F 在规范中一直为0</li><li>NRI 表明这个NALU 的重要性</li><li>Type 表明NALU 类型：<ul><li>1- 23 单个NAL 数据包</li><li>其他的组包格式</li></ul></li></ul><h3 id="几种常见的NALU-类型"><a href="#几种常见的NALU-类型" class="headerlink" title="几种常见的NALU 类型"></a>几种常见的NALU 类型</h3><p>主要介绍PPS、SPS和SEI:</p><ul><li><p>SPS(Sequence Parameter Sets，序列参数集):是H.264码流序列的第一个NALU。SPS 语法单元存放一个视频序列的共同特征。从SPS 中能获取图像的宽和高数据信息。如果SPS 丢失的话，解码大概率出现失败的情况。</p></li><li><p>PPS(Picture Parameter Sets，图像参数集): 是H.264码流序列的第二个NALU。PPS 语法单元存放一个视频图像的典型特征。</p></li><li><p>SEI(Supplemental Enhancement Information，补充增强信息):提供了向视频码流中加入额外信息的方法。</p></li></ul><h3 id="webrtc-h264-pack"><a href="#webrtc-h264-pack" class="headerlink" title="webrtc h264 pack"></a>webrtc h264 pack</h3><h4 id="STAP-A"><a href="#STAP-A" class="headerlink" title="STAP-A"></a>STAP-A</h4><pre><code class="txt">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                          RTP Header                           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|STAP-A NAL HDR |         NALU 1 Size           | NALU 1 HDR    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                         NALU 1 Data                           |:                                                               :+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|               | NALU 2 Size                   | NALU 2 HDR    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                         NALU 2 Data                           |:                                                               :|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                               :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+STAP-A NAL HDR 格式如下+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+其中F 和NRI 取NALU 1 的F 和NRI。 TYPE 默认都是24</code></pre><p>eg:<br>原始264 码流(带start-code):<br>sps [0  0  0  1  103  77  64  41  149  144  5  0  91  176  17  0  0  3  3  232  0  1  212  192  132]  pps [0  0  0  1  104  235  143  32] idr [0  0  0  1  101  184  4  11]</p><p>编码出来后的数据:<br>[120  0  21  103  77  64  41  149  144  5  0  91  176  17  0  0  3  3  232  0  1  212  192  132]<br>STAP-A NAL HDR ==&gt;103 ==&gt; 0110 0111 ==&gt; 011(1 1000 = 24) ==&gt; 01111000(120)<br>0 21 =&gt; nalu 1 len 21<br>[0  4  104  235  143  32]<br>0 4  =&gt; nalu 2 len 4</p><h4 id="FU-A"><a href="#FU-A" class="headerlink" title="FU-A"></a>FU-A</h4><pre><code class="txt">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| FU indicator  |   FU header   |                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               ||                                                               ||                         FU payload                            ||                                                               ||                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                               :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Figure 14.  RTP payload format for FU-AThe FU indicator octet has the following format:+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+Values equal to 28 and 29 in the type field of the FU indicator octet identify an FU-A and an FU-B, respectively. The use of the F bit is described in [Section 5.3].  The value of the NRI field MUST be set  according to the value of the NRI field in the fragmented NAL unit.The FU header has the following format:+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|S|E|R|  Type   |+---------------+S:     1 bit          When set to one, the Start bit indicates the start of a          fragmented NAL unit.  When the following FU payload is not the          start of a fragmented NAL unit payload, the Start bit is set          to zero.E:     1 bit          When set to one, the End bit indicates the end of a fragmented          NAL unit, i.e., the last byte of the payload is also the last          byte of the fragmented NAL unit.  When the following FU          payload is not the last fragment of a fragmented NAL unit, the          End bit is set to zero.R:     1 bit          The Reserved bit MUST be equal to 0 and MUST be ignored by the          receiver.Type:  5 bits          The NAL unit payload type was the fragmentation nalu type. </code></pre><p>eg: 编码一个I 帧 第一个字节为0x65=101，进行了分组<br>原始数据为<br>0x65 =&gt; 0110-0101<br>[101  184  4  11  255]</p><p>FU-idicator =&gt; 011 + 28(11100) =&gt; 01111100(0x7c)= 124<br>first fu-a FU-header =&gt; 100 + (nalu-type[00101])  =&gt; 10000101(0x85) = 133<br>middle fu-a FU-herader =&gt; 000 + (nalu-type[00101]) =&gt; 00000101(0x05) = 5<br>last fu-a FU-herader =&gt; 010 + (nalu-type[00101]) =&gt; 01000101(0x45) = 69<br><strong>不带naluHeader(101)的内容(0copy 客户端接收异常原因)</strong><br>第一个FU-A<br>[[124  133]  184  4  11  255]<br>中间的FU-A<br>[[124  5]  177  244  72  95]<br>最后一个FU-A<br>[[124  69]  212  53  47  240]</p><h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><pre><code class="c++">// 初始化packetizer 的最大包长度、和最后一个包冗余空间RtpPacketizer packetizer(maxpayload_len, reduction_len);// 输入一帧数据和nalu 分割信息int num_packets = packetizer-&gt;setPayload(data, len, frag);void setPayload(data, len, frag) {    // 根据frag 将一帧数据分为多个nalu，并塞入到input_fragments_ 中    input_fragments_.push_back(Fragment());    // 根据长度、打包类型进行打包    GeneratePackets();    return num_packet_left;}void GeneratePackets() {    for(input_fragments) {        case SingleNalUnit: packetSignaleNalu()        case NonInterleaved: PacketizeFuA() or PacketizeStapA()    }}// 一个nalu 拆为多个packetsvoid PacketizeFuA() {    // 1: 判断是否最后一个nalu，添加对应的 extenlen(头部扩展长度)    // 2: 需要发送的nalu的nalu header 不用保存，在nalu-header 保留nalu header 类型(fragment.length = naluHeadLen)    // 3: 每个包的负载大小为最大减去Fu-A 协议长度(indicator + header) 2 Byte    // 一个 nalu 14 bytes 包最大负载为5字节     // (14+(5-1))/5 = 3(packets)      // 14 / 3 = 4(bytes per packets)     // 14 % 3 = 2(first packets) 2 3 3 3 3    // 4: 计算分为多少个包、计算每个包的长度    // 5: 将一个nalu 划分为多个PacketUnit 塞进 packets_}// 多个nalu 合并为一个packetsvoid PacketizeStapA() {    // 循环(当前空间足够，即使是最后一个nalu 加上extlen 也足够)    // 将多个nalu 塞到多个PacketUnit 中，标识第一个包和最后一个包即可。}</code></pre><h2 id="RTP-RTCP协议"><a href="#RTP-RTCP协议" class="headerlink" title="RTP/RTCP协议"></a>RTP/RTCP协议</h2><p>分类：</p><p>RTP 关乎数据传输</p><p>RTCP 关乎数据传输控制</p><h3 id="RTP-协议和头部扩展"><a href="#RTP-协议和头部扩展" class="headerlink" title="RTP 协议和头部扩展"></a>RTP 协议和头部扩展</h3><h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><p>RTP 分组的首部格式：</p><img src=" ./RTP分组首部格式.png" srcset="/img/loading.gif" style="zoom:67%;" /><h4 id="包头信息"><a href="#包头信息" class="headerlink" title="包头信息"></a>包头信息</h4><p>包头各个字段信息如下所示：</p><img src="./RTP包头信息.png" srcset="/img/loading.gif" style="zoom:67%;" /><ul><li><p>版本号(V):2比特，标识rtp 版本</p></li><li><p>填充位(P):1比特，如果设置该位置的话，rtp包的尾部就包含附加的填充字节</p></li><li><p>扩展位(X):1比特，如果设置该位置的话，RTP 固定头部(12字节)后就跟着一个扩展头部</p></li><li><p>CSRC计数器(CC):4 比特，在固定头部后跟随的CSRC 的数目</p></li><li><p>标记位(M):1比特，由具体的解释文档说明，对于H264来说标识一帧的结束</p></li><li><p>荷载类型(PT):7比特，标识RTP荷载的类型</p></li><li><p>序列号:2字节，每发送一个RTP 数据包，序列号增加1。接收端根据此检测丢包和重建包序列</p></li><li><p>时间戳:4字节，记录一个时间戳</p></li><li><p>同步源标识符(SSRC):4字节，随机算法生成</p></li><li><p>贡献源列表(CSRC):4字节，0~15个CSRC，具体数目由CSRC 计数器(CC)计算生成。</p></li></ul><h4 id="头部扩展"><a href="#头部扩展" class="headerlink" title="头部扩展"></a>头部扩展</h4><p>  头部扩展如下：</p>  <img src="./RTP头部扩展.png" srcset="/img/loading.gif" style="zoom:67%;" /><p>如上所述，如果扩展位置为1，则一个长度可变的头扩展部分被加到RTP 固定头之后。头扩展包含16位比特的长度与，指示扩展项中32比特字的个数，但是不包含4字节扩展头的长度。为了实现特定的不同扩展，其中扩展项的前16位比特用以识别标识符或者参数。</p><p><strong>有且仅有一个头部扩展</strong></p><blockquote><p><a href="https://blog.csdn.net/machh/article/details/51868569" target="_blank" rel="noopener">https://blog.csdn.net/machh/article/details/51868569</a></p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcBWE</title>
    <link href="/2020/09/10/WebrtcBWE/"/>
    <url>/2020/09/10/WebrtcBWE/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 带宽预估以及拥塞控制相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcNetwork</title>
    <link href="/2020/09/10/WebrtcNetwork/"/>
    <url>/2020/09/10/WebrtcNetwork/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 弱网对抗相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcRateControl</title>
    <link href="/2020/09/10/WebrtcRateControl/"/>
    <url>/2020/09/10/WebrtcRateControl/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 流控相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcVideo</title>
    <link href="/2020/09/10/WebrtcVideo/"/>
    <url>/2020/09/10/WebrtcVideo/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 视频相关整理</p><a id="more"></a><p><img src="./video_receive_render.png" srcset="/img/loading.gif" alt="video_receive_decoder"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcCall_PeerConnection</title>
    <link href="/2020/09/10/WebrtcCall_PeerConnection/"/>
    <url>/2020/09/10/WebrtcCall_PeerConnection/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 会话控制管理以及PeerConnection相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcStats</title>
    <link href="/2020/09/10/WebrtcStats/"/>
    <url>/2020/09/10/WebrtcStats/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 统计数据相关整理</p><a id="more"></a><h1 id="getStats"><a href="#getStats" class="headerlink" title="getStats"></a>getStats</h1><p>based on commit: d4089cae47334a4228b69d6bb23f2e49ebb7496e</p><h2 id="call-chain"><a href="#call-chain" class="headerlink" title="call-chain"></a>call-chain</h2><img src="./call_chain.jpg" srcset="/img/loading.gif" style="zoom:50%;" /><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><ul><li>frameRate: receiveFps、decodeFps、dropFps、renderFps</li><li>bps: rtpBps(ori + fec)、rtxBps、payLoadBps(%)</li><li>transport: rtt、jitterBufferDelay、jitterBufferEmittedCount(from packet queue to jitterBufferDelay and Count)</li><li>rtcp: pliCount、nackCount</li></ul><p>base on these IDL:</p><ul><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats" target="_blank" rel="noopener">RTCRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats" target="_blank" rel="noopener">RTCReceivedRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats" target="_blank" rel="noopener">RTCInboundRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats" target="_blank" rel="noopener">RTCRemoteInboundRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcsctptransportstats" target="_blank" rel="noopener">RTCTransportStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats" target="_blank" rel="noopener">RTCIceCandidatePairStats</a></li></ul><p><a href="https://juejin.im/post/6844903792001974280" target="_blank" rel="noopener">https://juejin.im/post/6844903792001974280</a><br><a href="https://blog.csdn.net/Chengzi_comm/article/details/89526935" target="_blank" rel="noopener">https://blog.csdn.net/Chengzi_comm/article/details/89526935</a></p><h2 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h2><img  src=http://www.plantuml.com/plantuml/svg/lLJRQW8n47tFLmIVse9_84AnGejTA2ZjewIxeuQkoPADjb3yz-RYhfDaLx4F1a7DEScSEJCJKh7yYws13hxXK-byG7u9DIilMLtJTrw0pA3WRB9XGa3fCC-mQozvGTUWvvhf-kxUxH_mUSbpkFeyCPzMrlnfrcXgzzoDSws0RGVHZJuk8hJ8YMENOqp5cWluKAogGD4bkBy1hH7eZ7WHAtaKcIImOGhEu8-xWiVd3-slBlM1jfuaalAOlUNURbwcrLPnI8kBPMdC2h-X9GHzXVNsXZJrZYppAJ9XwEfSnNrFcBos7HtIgfF2DYIlDS_hLDqfgalnvb6TSJUFch6V3BGoh9wOpul56rrkjAxETNXJq-dhZ8v6arBkYl6uvqOVsDvxUMOcKgmIJ-W_J36T99kQ7eSf2mZO_au2xefEmibAAoFq5DLbmRUWalV2Fu-4f4Cz7CgkfoCTwnuYwNWJM-hHAO87pQ7O-23p60nyYq62YsF1OA1ZC9Yx60p68mPnJDUmPlS1zpQgpR24bJOeFlC7><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Videojitterbuffer</title>
    <link href="/2020/09/08/videojitterbuffer/"/>
    <url>/2020/09/08/videojitterbuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="JitterBuffer"><a href="#JitterBuffer" class="headerlink" title="JitterBuffer"></a>JitterBuffer</h1><p>based on:m74(commit cc1b32545db7823b85f5a83a92ed5f85970492c9)</p><h2 id="RtpVideoStreamReceiver"><a href="#RtpVideoStreamReceiver" class="headerlink" title="RtpVideoStreamReceiver"></a>RtpVideoStreamReceiver</h2><img  src=http://www.plantuml.com/plantuml/svg/hLTDRzCm6BxdLrWxRHMz8CIbQ1BhFgWG5BLZrof9tH6jTKlY5QQn0sAW0WNjW11ZOW8nQRjGnWNn_Mj8Mqxy1Hp7IUpOJWiYXpQnd_Tzd_V3hssZOzeRvZe4CxUWvM9xnjWs07bCoyEkQMDWDqtF0ulGRjTXlTGYqABPR5f42eJ8uEcsdJh3pCuLmFZuxUZrNN_G7_Rs_BsdevUx_i7X-FGUnUyOAWDhJXssGmskLh4uN87hZeUX6quNswrE4-AOtQoASWxO5bF3Q8JMBvqzVqvZlEX24yV6TL8bOZmj-L_uAGEVpxVJnaCqxqS-VsTU26iQGJbJ53UeJqxLGHibHFnfc3QyG8UMNRC5vzD-bn4TJuKifN89JIweCk9HsVgk4lagH8e41gF1RBRyPRX5MLVWpKteORKgDXbXipMMKPHo2jOxAS2oTLQta6rQJKYKPA02KrLiOgziUT3jodwKKGNZwvswhh2l4PuGBsms6bHM1h1GaMc8RBZii639mBNYbLMdvQ1rvMm5TyBImcIHjIhGXex8LY3IuJvgIIzGScdGFmuL4yc1hjt2zBKck2xO2bQOcfsXjQcN0LBiujXEpoyEw0f4q7NigPkbq5hhuR-eMa04RaXMKXHOLyeix6Gxk47Q2ziIza_2dS3ldGxV7Vb7kx-_zVq7JyWd5xQ8oV3XyVXDdyKQHHqiugnXGHkQgciQAH-A164lcjXSC3sOa9TSpu4LYDdxBBLrHcUSQz_fJM3fDlb1PZDIbC0K1iCzvoAgbv234mc_T-1__U9__kZtNld7Z_t-ypYgMcMWWzsQEkaIb6LU2Co4MF-BG93eU3K9IU5dfbiRR5hCPM3O3ju4Z98G2qquQbi5eDx26QbuxoRgKaDXwead5l1FFmnVl5VKCwdxqREJyU37wFiWRVclJZpfOkBNRovQudCJbhYG1cKSjJ3MqYSqIH78jJt5RAeeL6SGAUJfXaCjhBR3Lg687HMkip98chTYr-LFFK86jyMc6jTgb_-g5QRa9H-hSi0X9nvQtrHbpQFcQmNW3mv_xT__-UaHLrtCO4YHvrzYIZWFaYWB7d758NeQdXwbc7FusFaipM4aLNp4yu2QSNI05MAaxHYnOcMEmba-_F8Y8uSc5_C3_5xTIDwv36isV5SvN2jewWTeAqYHcguqf3hda5OfTKfLb1rvJ74ua9CjnbLVHXbmVGVWK7mAid2QHEX434s1QAik4w-wpMHB9FULR9poNf8jehbuP0j5Dujib7IpC7QCFm00><h2 id="VideoReceiver"><a href="#VideoReceiver" class="headerlink" title="VideoReceiver"></a>VideoReceiver</h2><h2 id="VideoStreamDecoder"><a href="#VideoStreamDecoder" class="headerlink" title="VideoStreamDecoder"></a>VideoStreamDecoder</h2><h2 id="VCTiming"><a href="#VCTiming" class="headerlink" title="VCTiming"></a>VCTiming</h2><h2 id="PacketBuffer"><a href="#PacketBuffer" class="headerlink" title="PacketBuffer"></a>PacketBuffer</h2><p>作用： 包缓存，返回数据帧(如何定义帧？)到RtpVideoStreamReceiver</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[PacketBuffer]<ul><li>size(512-2048个pkt)</li><li>buffer<ul><li>sequence_buffer 保存pkt信息</li><li>data_buffer 保存真实pkt</li></ul></li><li>InsertPacket() 插入数据包</li><li>UpdateMissingPackets() 更新丢失pkt，用于检测P帧前的gap</li><li>FindFrames() 查找可用帧，并回调</li><li>PotentialNewFrame() 查找潜在连续帧</li><li>PaddingReceived() 更新padding</li></ul></li></ul></blockquote><pre><code class="c++">void FindFrames(uint16_t seq) {    for(最多找一圈，并且序列号是连续) {        if(currentPacket == frame_end) {            while(1) {            }            if(is_264) {                // 如果不是关键帧，当前帧前面有丢失的数据包                // 充值data_buffer 相关数据包的状态                if(!iskeyframe &amp;&amp; gap()){                    reset_databuffer_status();                }            }            missing.erase();            found_frames.insert();        }    }}</code></pre><p>可以考虑的两个点：</p><ul><li>nackCount</li><li>max(min)recvtime</li></ul><h2 id="RtpFrameReferenceFinder"><a href="#RtpFrameReferenceFinder" class="headerlink" title="RtpFrameReferenceFinder"></a>RtpFrameReferenceFinder</h2><p>作用：找到每一个帧的参考帧，关键帧是自参考，后续的GOP内的每一帧都参考上一帧，GOP 内有序。</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[RtpFrameReferenceFinder]<ul><li>ManageFrame()<ul><li>ManageFrameInternal()</li><li>ManageFramePidOrSeqNum()</li></ul></li><li>PaddingReceived()</li><li>UpdateLastPictureIdWithPadding()</li><li>RetryStashedFrames()</li><li>ClearTo()</li></ul></li></ul></blockquote><pre><code class="c++">void ManageFramePidOrSeqNum() {    // 1.插入关键帧 last_seq_num_gop(关键帧最后一个包序列号，作为下一帧的依赖)    // 2.关键帧为空，直接缓存    // 3.删除较老的关键帧信息，至少保存一个关键帧序列号    // 4.如果是P帧的话，判断序列号是否和上一个连续帧的最后一个序列号相等，否则返回缓存    // 5.更新关键帧序列的最后一个连续帧序列号，作为下一帧的依赖，和1 相互呼应    // 6.更新最后一个序列号考虑padding 场景}void UpdateLastPictureIdWithPadding(seq) {    // 1.如果当前序列号比关键帧序列号还老，返回    // 2.获取当前seq 所依赖的关键帧信息    // 3.如果有因padding 包存在可以使得序列号连续的，更新包的序列号    // 4.极端情况下，清楚关键帧信息和状态}void RetryStashedFrames() {    // 有两种情况可以尝试从stashed 中查找    // a. 缓存帧遍历查找    // b. 因padding 包的存在，可以使得序列号连续    // 1. 从缓存帧处遍历，查看是否能找到连续的帧}</code></pre><h2 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h2><p>作用：GOP间 内有序。</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[FrameBuffer]<ul><li>Public<ul><li>Start() 随着videoreceivestream start</li><li>Stop() 随着stop</li><li>SetProtectionMode()</li><li>Clear()</li><li>InsertFrame() 插入数据帧<ul><li>1.获取最近解码帧的时间戳以及序列号</li><li>2.针对跳帧情况特殊处理，id_small&amp;&amp;time_new&amp;&amp;keyframe</li><li>3.还是针对跳帧，插入会导致混乱情况，返回</li><li>4.尝试插入，如果已经存在，返回</li><li>5.判断当前帧是否因为重传导致延时(一定范围内？整个一帧？)</li><li>6.如果当前真的参考都到期了，计算准备返回可解码帧id</li></ul></li><li>UpdateRtt() 根据rtt 调整jitterEsmitor 策略</li><li>NextFrame() 弹出数据帧</li></ul></li><li>ValidReferences() 判断帧之间的参考是否正确，</li><li>UpdateFrameInfoWithIncomingFrame() 更新frameinfo 和其他frame的info</li></ul></li></ul></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>webrtc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>jitterbuffer</tag>
      
      <tag>pakcetbuffer</tag>
      
      <tag>referencefinder</tag>
      
      <tag>framebuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProjectCompile</title>
    <link href="/2020/09/04/ProjectCompile/"/>
    <url>/2020/09/04/ProjectCompile/</url>
    
    <content type="html"><![CDATA[<p>Google Chromium 和 Webrtc 编译调试</p><a id="more"></a><h1 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h1><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><pre><code class="shell"># depot_toolsgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git# export toolsexport PATH=&quot;$PATH:/path/to/depot_tools&quot;# fetch# 查看哪些项目代码可以获取fetch --help# 获取对应代码fetch webrtc</code></pre><h2 id="Webrtc"><a href="#Webrtc" class="headerlink" title="Webrtc"></a>Webrtc</h2><pre><code class="shell"># 创建文件夹 拉取代码  同步代码mkdir webrtc-checkout &amp;&amp; cd webrtc-checkout &amp;&amp; fetch webrtc &amp;&amp; gclient sync# 生成ninja projectgn gen out/Default# 编译ninja -C out/Default# 使用ccache 加速编译# out-gn 是编译生成的目录 类似cmake 的build 文件夹# https://chromium.googlesource.com/chromium/src/+/master/docs/ccache_mac.md# 针对webrtc 不能在args.gn 文件中设置 is_component_build = true# 可以在args.gn 文件中查看到对ccache 的设置 cc_wrapper = &quot;ccache&quot;gn gen out-gn --args=&#39;cc_wrapper=&quot;ccache&quot;&#39;ninja -C out-gen# https://webrtc.github.io/webrtc-org/native-code/development </code></pre><h2 id="Chromuim"><a href="#Chromuim" class="headerlink" title="Chromuim"></a>Chromuim</h2><pre><code class="shell"># 创建文件夹 拉取代码mkdir chrome &amp;&amp; cd chrome &amp;&amp; fetch chromium# 生成ninja projectgn gen out/Default# 编译ninja -C out/Default# 生成的可执行文件在 Chromium.app/Contents/MacOS# https://chromium.googlesource.com/chromium/src/+/master/docs/mac_build_instructions.md# 切换到指定分支编译 # 拉取代码 拉取tagsgit fetch &amp;&amp; git fetch --tags# 根据tag 切换到指定的taggit checkout -b localbranch tagname# 更新所有submodule 的代码gclient sync --with_branch_heads --with_tags# chromium 对应分支信息# https://chromiumdash.appspot.com/branches# http://www.chromium.org/developers/how-tos/get-the-code/working-with-release-branches# https://blog.csdn.net/chinabinlang/article/details/100122002# 使用ccache 加速编译过程# https://chromium.googlesource.com/chromium/src/+/master/docs/ccache_mac.md# 开启日志./chrome --enable-logging --v=1# https://blog.csdn.net/foruok/article/details/71080012# 日志位置 分两种情况# 如果是安装版本的chrome 的话~/Library/Application Support/Google/Chrome/chrome_debug.log# 如果是自己编译的chromium 的话~/Library/Application Support/Chromium/chrome_debug.log</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>chromuim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Gtest</title>
    <link href="/2020/09/02/Gtest/"/>
    <url>/2020/09/02/Gtest/</url>
    
    <content type="html"><![CDATA[<p>Google Gtest 单元测试框架相关整理</p><a id="more"></a><h1 id="Gtest-amp-Gmock"><a href="#Gtest-amp-Gmock" class="headerlink" title="Gtest&amp;Gmock"></a>Gtest&amp;Gmock</h1><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><pre><code class="shell"># --gtest_list_tests 不会执行测试案例，而是输出一个案例的列表# --gtest_filter 对执行的测试案例进行过滤，只执行匹配的案例</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LinuxMem</title>
    <link href="/2020/08/31/LinuxMem/"/>
    <url>/2020/08/31/LinuxMem/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Mem"><a href="#Linux-Mem" class="headerlink" title="Linux-Mem"></a>Linux-Mem</h1><h2 id="什么是buffer-cache"><a href="#什么是buffer-cache" class="headerlink" title="什么是buffer/cache"></a>什么是buffer/cache</h2><p>buffer 指的是buffer cache，中文语境下为：缓冲区缓存，历史上主要是对io 设备写的缓存<br>cache  指的是page cache，中文语境下为：页面缓存，历史上主要是对io 设备读的缓存</p><p>但是目前，他们两个的意义已经不一样了，如果内存是以page 进行分配管理的，都可以使用page cache 作为其缓存来管理使用。当然并不是所有的内存都是以page 来管理的，还有按照block 来进行管理的，一般叫做buffer。</p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Computer</title>
    <link href="/2020/08/28/Computer/"/>
    <url>/2020/08/28/Computer/</url>
    
    <content type="html"><![CDATA[<h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h2><h3 id="周期"><a href="#周期" class="headerlink" title="周期"></a>周期</h3><p>三个周期：时钟周期、机器周期、指令周期<br>CPU 最小生命单位就是时钟周期，一个机器周期包含若干个时钟周期，至于指令周期则包含若干机器周期。按照粒度排序：<br>指令周期 &gt; 机器周期 &gt; 时钟周期<br>时钟周期：在一个时钟周期内，cpu 仅完成一个最基本的动作<br>机器周期：<br>指令周期：执行一条指令所需要的时间，一般由若干个机器周期组成。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Perf</title>
    <link href="/2020/08/28/perf/"/>
    <url>/2020/08/28/perf/</url>
    
    <content type="html"><![CDATA[<p>perf 基本原理是在cpu PMU(performance Monitor Unit) 寄存器和软件特性中获取相关信息来进行系统性能输出。<br>可以监控的事件分为三类:</p><ul><li>Hardware Event 这块主要是由PMU 寄存机硬件产生的，如如cache miss 等，如果需要了解程序对硬件特性使用情况，需要使用这类事件</li><li>Software Event 内核软件产生的时间，比如进程切换  tick 数</li><li>Tracepoint Event 内核中的静态tracepoint 触发的时间，这些tracepoint 用来判断程序运行期间内核的行为细节，比如slab 分配器的分配次数等<pre><code class="shell"># 可以使用/ 进行某些关键字查询$ perf top# 单独的监控某一个应用程序# 事件这么多，不知道监控哪一些，无从下手，最好先从整体到细节。先大致了解有哪一些统计事件，在到具体细节中去# 使用perf stat 可以通过精简的方式提供程序运行的整体情况和数据汇总$ perf stats xxx.exe# task-clock 指的是占用了多少任务时钟周期，越高说明多数时间话费在CPU 计算上</code></pre></li></ul><p>$ perf record -g -e kmem:* -F 99 -p 12413 – sleep 20<br>$ perf record -g -e kmem:* -F 99 command<br>$ perf kmem -i perf.data –caller stat</p><h1 id="perf-生成火焰图"><a href="#perf-生成火焰图" class="headerlink" title="perf 生成火焰图"></a>perf 生成火焰图</h1><p>FlameGraph/stackcollapse-perf.pl result.perf &gt; result.folded<br>FlameGraph/flamegraph.pl result.folded &gt; cpu.svg</p><p>diff 火焰图</p><p>除了通常的几种火焰图，我们其实还可以将两个火焰图进行 diff，生成一个 diff 火焰图，</p><p>./FlameGraph/difffolded.pl perf.folded perf.folded1 | ./flamegraph.pl &gt; ../diff.svg</p><p>```<br><a href="https://juejin.im/post/6844903950315945992" target="_blank" rel="noopener">https://juejin.im/post/6844903950315945992</a><br><a href="http://linux.51yip.com/search/perf" target="_blank" rel="noopener">http://linux.51yip.com/search/perf</a><br><a href="https://blog.csdn.net/qq_15437667/article/details/50724330" target="_blank" rel="noopener">https://blog.csdn.net/qq_15437667/article/details/50724330</a><br><a href="https://www.cnblogs.com/sunsky303/p/8328836.html" target="_blank" rel="noopener">https://www.cnblogs.com/sunsky303/p/8328836.html</a><br><a href="http://www.brendangregg.com/perf.html" target="_blank" rel="noopener">http://www.brendangregg.com/perf.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Keyword</title>
    <link href="/2020/08/20/keyword/"/>
    <url>/2020/08/20/keyword/</url>
    
    <content type="html"><![CDATA[<p>快捷键</p><a id="more"></a><h1 id="KeyWord"><a href="#KeyWord" class="headerlink" title="KeyWord"></a>KeyWord</h1><h2 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h2><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><h4 id="多列选择"><a href="#多列选择" class="headerlink" title="多列选择"></a>多列选择</h4><pre><code class="txt">shift+option 鼠标左键</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>LinuxCpu</title>
    <link href="/2020/08/13/LinuxCpu/"/>
    <url>/2020/08/13/LinuxCpu/</url>
    
    <content type="html"><![CDATA[<h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1><h2 id="如何查看CPU-数量"><a href="#如何查看CPU-数量" class="headerlink" title="如何查看CPU 数量"></a>如何查看CPU 数量</h2><p>一般来说，一颗物理CPU 上可以分出多个逻辑核心，加上intel 的超线程技术，可以在逻辑核心上再分出一倍数量的核心出来。</p><pre><code># 如果是相同physical id 的cpu，那么是同一个物理核心封装的物理核或者超线程# 如果是相同core id 的cpu，那么是同一个逻辑核的超线程$ cat /proc/cpuinfo# 查看有多少个物理核心$ cat /proc/cpuinfo | grep &quot;physical id&quot; | sort | uniq | wc -l#查看有多少个逻辑核心$ cat /proc/cpuinfo | grep &quot;processor id&quot; | wc -l</code></pre><h2 id="CPU-平均负载"><a href="#CPU-平均负载" class="headerlink" title="CPU 平均负载"></a>CPU 平均负载</h2><p>top 和 uptime 命令都可以查看</p><p>系统负载升高的原因:<br>一般来说，系统平均负载升高意味着CPU 利用率上升，但是没有必然联系。<br>对于CPU 密集型的操作来说平均负载上升，一般意味着CPU 利用率上升。<br>如果是IO 密集型任务较多的话，此事的CPU 利用率不一定高，可能很多任务处于不可中断状态，等待CPU的调度也会升高平均负载。</p><p>所以在遇到系统平均负载很高，但是CPU利用率上不去的时候，就需要考虑系统是否遇到了IO 瓶颈。<br>因此系统是否遇到CPU瓶颈需要结合CPU 利用率，系统平均负载来查看。</p><p><a href="https://community.tenable.com/s/article/What-is-CPU-Load-Average" target="_blank" rel="noopener">https://community.tenable.com/s/article/What-is-CPU-Load-Average</a><br><a href="https://scoutapm.com/blog/understanding-load-averages" target="_blank" rel="noopener">https://scoutapm.com/blog/understanding-load-averages</a><br><a href="https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2011/07/linux_load_average_explained.html</a></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>C++Tips</title>
    <link href="/2020/08/05/C-Tips/"/>
    <url>/2020/08/05/C-Tips/</url>
    
    <content type="html"><![CDATA[<h1 id="Tips"><a href="#Tips" class="headerlink" title="Tips"></a>Tips</h1><h2 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h2><pre><code class="c++">// 需要移位的数字 &lt;&lt; 移位的次数n// 4*2^2 = 164 &lt;&lt; 2 </code></pre><h2 id="STL"><a href="#STL" class="headerlink" title="STL"></a>STL</h2><h3 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound upper_bound"></a>lower_bound upper_bound</h3><pre><code class="c++">// 返回一个迭代器，指向键值&gt;= key的第一个元素// 如果没有找到合适的返回end()iterator lower_bound(const key_type&amp; key);// 返回一个迭代器，指向键值&gt; key的第一个元素// 如果没有找到合适的返回end()iterator upper_bound(const key_type&amp; key);vector&lt;int&gt; a{1,2,3,4,5,6,7,8};auto lowerIt = lower_bound(a.begin(), a.end() ,12);// lowerIt = end()auto upperIt = upper_bound(a.begin(), a.end() ,12);// upperIt = end()auto lowerIt = lower_bound(a.begin(), a.end() ,2);// *lowerIt == 2auto upperIt = upper_bound(a.begin(), a.end() ,2);// *upperIt == 3</code></pre><h2 id="分支预测"><a href="#分支预测" class="headerlink" title="分支预测"></a>分支预测</h2><p>gcc 引入，作用是允许将最有可能执行的分支告诉编译器，减少指令跳转带来的性能下降。<br>这个指令的写法是<strong>builtin_expect(EXP,P)。<br>一般是将</strong>builtin_expect 封装为likely和unlikely 宏，如下：</p><pre><code class="c++">#define likely(x) __builtin_expect(!!(x), 1) //x很可能为真       #define unlikely(x) __builtin_expect(!!(x), 0) //x很可能为假</code></pre><p>使用likely()，执行if 后的概率大一些，使用unlikely() 执行else 后面语句的概率大一些。</p><pre><code class="c++">// 下面例子编译的指令会预先读取y = 1 这个指令，这是和x  &gt; 0 的概率比较大的时候，如果x &gt; 0 的概率比较小，那么就应该使用 unlikely 这个指令 int x,y;if(likely(x &gt; 0)) {    y = 1;} else {    y = -1;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>DevelopeKit</title>
    <link href="/2020/08/04/DevelopeKit/"/>
    <url>/2020/08/04/DevelopeKit/</url>
    
    <content type="html"><![CDATA[<h1 id="DevelopeKits"><a href="#DevelopeKits" class="headerlink" title="DevelopeKits"></a>DevelopeKits</h1><h2 id="Command"><a href="#Command" class="headerlink" title="Command"></a>Command</h2><h3 id="z-sh"><a href="#z-sh" class="headerlink" title="z.sh"></a>z.sh</h3><p><a href="https://github.com/rupa/z.git" target="_blank" rel="noopener">zsh</a></p><h3 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h3><p><a href="https://github.com/tldr-pages/tldr" target="_blank" rel="noopener">tldr</a></p><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><pre><code class="shell"># 压缩打包一个文件夹zip -r dst.zip folder# 压缩打包一个文件zip dst.zip file</code></pre><h3 id="把数据同时输出到文件和屏幕"><a href="#把数据同时输出到文件和屏幕" class="headerlink" title="把数据同时输出到文件和屏幕"></a>把数据同时输出到文件和屏幕</h3><pre><code class="shell">./happy_day | tee log.txt | cat</code></pre><h3 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h3><pre><code class="shell">#表明把标准输出重定向到文件 ./happy_day &gt; file#把标准错误输出重定向到标准输出./happy_day 2&gt;&amp;1 file./happy_day &amp;&gt; file</code></pre><h2 id="grep-和find-配合"><a href="#grep-和find-配合" class="headerlink" title="grep 和find 配合"></a>grep 和find 配合</h2><pre><code class="shell">find ./dir -name &quot;*cpp&quot; | xargs grep &quot;xxxx&quot;# 查找文件 -type ffind ./dir -type f | xargs grep &quot;xxxx&quot;</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>PeerConnection</title>
    <link href="/2020/08/02/PeerConnection/"/>
    <url>/2020/08/02/PeerConnection/</url>
    
    <content type="html"><![CDATA[<p>和PeerConnection 有关的一切</p><a id="more"></a><h1 id="PeerConnection"><a href="#PeerConnection" class="headerlink" title="PeerConnection"></a>PeerConnection</h1><p>based on commit: d4089cae47334a4228b69d6bb23f2e49ebb7496e<br>useful file: </p><ul><li>conductor.cc(examples/peerconnection/client)</li><li>simple_peer_connection.cc(examples/unityplugin)</li></ul><h2 id="拉取webrtc-代码"><a href="#拉取webrtc-代码" class="headerlink" title="拉取webrtc 代码"></a>拉取webrtc 代码</h2><p>拉取分支</p><pre><code class="shell">git clone https://chromium.googlesource.com/external/webrtc#设置git config#在 .git/config 文件中的  `[remote &quot;origin&quot;]` 节中添加以下内容：# fetch = +refs/branch-heads/*:refs/remotes/origin/*git pull# 拉取远端tagsgit fetch --tags</code></pre><img  src=http://www.plantuml.com/plantuml/svg/dLTTRzn457tVNp7gGxIxogeelDKbKjc2L8bAKLQKHyjhJnEhwmyyinjLW9G2gHO4H9Le12LGYbIAGEm6zO6aRSYFOUrrdlWBp7ZizNpP6_1BrkDxxznxvjnp9utGikzOMn1SiYFNlWFnfSO73K0UguzmPDaOs0CB8N0JEgxLtRPy7mu0iw1FFmW6u9hZzA3lz704BQzf1px2WBriM97beHM0mfOX-cn2BnX1pcte-lZrDHC3X29RjYOxR49xz3zsuDnqEtpKq1LxotLW85NCcwlVEvqFrmMCgkEIZA1BIi-IaW8pi_TWVnFRMkEYGlLZ6w3ihsaecOf1EfsWSWS-2_Nh6fS02Zm8HjPW2941veUFuyaFyqUVZgXFn7nOElN9h37WwXFXaYtviWouQgfoZ6WPuFBbClju_5tyyaKTj-iT47QkNF6iy6h1jDLAeDlh88V9P3WXyu9Xocn834HUr00yC9LSacXGq5RouG2lS90zX8vG6gMwBTxojrmVtl0nZ6vRDfIvpWTfWox924D-hTa2Ru3NZ5fEi2t-UsHZMUy7sX9gp9Ma51ZpN4iKvU2L8bq3PE3QKFgy0aPqbOTlaRPgIbShaUu6NXWWDqTF1RjsToBLKKJ2NpI5XRt4TosNAEIwx38FRTgbdby4zpSj15N14OdbqJVJ5ZcrQFUXxxu_X6Q8ewkysxhePjQDHNEdSZ2cHv_Cl_v520M8V4bYACRkGKmdA8RTWDJkOnAUg5-z3R6OdPwHhRAQ-gxlDDKmgtZRHIr05FJysxtPyUVq5IJVJ4USUYJZWtHtB-C6Bqpv6KljrERnLoQOUYwQhgyyd1eeqibVyzD9UdOu_srAm4HE26PdJv9xqtzUVP5-zMUyVq3l6M3--sVn_RruSf9y_pHzzdEy_u1DZL4koJdyuexlXWvH8RPfBvVtdMPhoV6tYadCpIM-BGHfvZ4ZHejhu0xiHzYcjq2-jPdXJSidDf7CSQb52ZXXjindlTpQbFfVqkLRDyerMYxlsbdF80MpLu_YlJ63O7QyEpl-LJdmve9yX7Vgx6gjWdJwD9wUf7yycPqUpevVnFiV9m-FM4nbNEeX3YJGEEfgvKbZpB3VW30YnFEXZTt0r-cwAiMYpzj4gOBeBkSXxjOkba6XCnxxODOV7LqN3myaXxlpbsDwyGRn-4WggeXLKL5noE9dQVnMeK4nr5RDt2G2Bx6k19vSUAMBPuLHrc8LkLRlaNqeJudedmEk1mlvkGuH-ISjPAY8LjV2S73tdS2s1eAHGRk1gJ_3DiS1aGcQ79mapnzgmcWsCqGpALOF8aJCE8-MaVnuadmveQ98xyc50B8EEd_yF7rs__od1t_ltYCwPnMq4pTX6fZ7xc7oMnX0MddWrl9Xc4qYCgnTVsi5UAuZbx8nHDjEiEDd_1Ph9ZTz1bsU7Yb47NXqE6IuboiwOBSWfYKWMW8eY-XQWm7GF2GUF-prxGp0RVRBhEcGIYOIbbwiCnfaFFmB><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>PeerConnection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxDebug</title>
    <link href="/2020/07/29/LinuxDebug/"/>
    <url>/2020/07/29/LinuxDebug/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Debug"><a href="#Linux-Debug" class="headerlink" title="Linux-Debug"></a>Linux-Debug</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre><code class="shell"># 支持三种类型的断点# 1 普通断点 break # 2 观察断点 watch # 3 普通断点 ？？ watch value</code></pre><h2 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h2><p>系统默认不会生成core 文件，依赖shell 中的设置。</p><pre><code class="shell">$ ulimit -a# -c: core file size (blocks)         0 这一行表示不会有core 文件生成-t: cpu time (seconds)              unlimited-f: file size (blocks)              unlimited-d: data seg size (kbytes)          unlimited-s: stack size (kbytes)             8192-c: core file size (blocks)         0-v: address space (kbytes)          unlimited-l: locked-in-memory size (kbytes)  unlimited-u: processes                       1392-n: file descriptors                10240# 允许生成core 文件，文件大小不受限$ ulimit -c unlimited# 默认core 和可执行文件在同一目录，但可以设置# /proc/sys/kernal/core_pattern 可以格式化core 文件路径和文件名</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Security</title>
    <link href="/2020/07/27/Security/"/>
    <url>/2020/07/27/Security/</url>
    
    <content type="html"><![CDATA[<p>加解密以及ssh 登录原理备忘</p><a id="more"></a><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一套秘钥，加密强度高，难以被破解。随之而来的问题就是如何安全的保存秘钥，特别是客户端庞大的时候，很难保证秘钥不被泄露。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥和私钥</p><p>公钥和私钥都可以加密和解密，公钥加密私钥解密，私钥加密公钥解密。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>中间人在客户端和服务端中间，让客户端误以为是真实的服务端，从而获取相关内容。</p><h4 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h4><p>数字签名：对data 进行hash，将hash 生成的摘要用私钥进行加密。并附在data 发给对方。对方使用公钥进行解密，获取了hash值和data，对data 进行hash 和机密的摘要进行对比。判断内容是否被篡改。</p><p>这有个问题就是公钥的分发可能被欺骗，比如我接收银行的公钥，对银行发送给我的内容进行验证。结果黑客将我保存的银行的公钥替换为黑客的公钥。这个时候我还以为我收到的是银行的公钥，这个时候黑客就可以让我误以为使用了银行的公钥进行通信。</p><p>数字证书，找一个第三方对银行的公钥进行公证，后续我使用都回去公证中心进行验证数据是否正确。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>ssh 主要用于计算机之间的加密登录，仅仅是一个标准的协议，具体的实现有很多种，目前使用范围最广泛的是OpenSSH。</p><pre><code class="shell">ssh user@host -p port</code></pre><p>ssh 不像https 有证书中心进行公钥的公证，那么就有可能在客户端和服务端中间存在”中间人攻击”。</p><h3 id="ssh-如何解决中间人攻击"><a href="#ssh-如何解决中间人攻击" class="headerlink" title="ssh 如何解决中间人攻击"></a>ssh 如何解决中间人攻击</h3><h4 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h4><p>通常在第一次登录的时候，系统会出现下面提示信息：</p><pre><code class="shell">ssh user@hostThe authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?</code></pre><p>上面大概意思是，无法确定主机的真实性，不过知道他的公钥信息，询问你是否继续？</p><p>所谓公钥信息，就是指公钥的数字摘要(通过MD5生成的)。</p><p>很自然的一个问题就是如何知道远程主机的公钥指纹是多少？远程主机必须在自己的网站上贴出公钥指纹，以方便用户自己比较。</p><p>远程主机的公钥被接收后，会被保存在文件~/.ssh/known_hosts 中，下一次再连接该主机的时候，就会自动跳过警告部分，直接要求输入密码了。</p><h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><p>使用口令登录，每一次都需要输入密码，比较麻烦，ssh 提供了另外一种免去输入密码的登录方式：公钥登录</p><p>公钥登录：客户端自己生产公钥和私钥密钥对，将自己的<strong>公钥</strong>保存在远程主机上。</p><p>登录原理：远程主机向客户端发送一个随机字符串，用户用私钥加密后，再发回来。远程主机用公钥进行解密，并将机密后的字符串和随机字符串比对，如果成功，允许登录shell，不再要求密码。</p><pre><code class="shell">#远程主机的authorized_keys 文件保存了用户的公钥ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><pre><code class="shell">#生成私钥openssl genrsa &gt; cert.key#从私钥中获取公钥openssl rsa -in cert.key -pubout -out pub.pemopenssl rsa -in cert.key -pubout -text -out pub.pem#生成证书openssl req -new -x509 -key cert.key &gt; cert.pem#生成证书的fingerprintopenssl x509 -fingerprint -sha256 -in cert.pem</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>加解密</tag>
      
      <tag>openssl</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络抓包</title>
    <link href="/2020/03/29/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/"/>
    <url>/2020/03/29/%E7%BD%91%E7%BB%9C%E6%8A%93%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<p>网络抓包工具指令备忘</p><a id="more"></a><h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><p>“源码面前，了无秘密”，同理在抓包工具面前，网络的各种情况也原型毕露。</p><p>本文主要给大家介绍三个主流的抓包工具以及如何对https 协议进行抓包，更多的是介绍工具的使用以及实操。</p><h1 id="主要工具介绍"><a href="#主要工具介绍" class="headerlink" title="主要工具介绍"></a>主要工具介绍</h1><p>工具主要包括：</p><ul><li>tcpdump</li><li>wireshark</li><li>fiddler</li></ul><h1 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h1><h2 id="tcpdump-实例"><a href="#tcpdump-实例" class="headerlink" title="tcpdump 实例"></a>tcpdump 实例</h2><pre><code class="shell"># tcpdump -i 指定对应的网卡 将抓包数据写入指定文件tcpdump -w fxxkWall.pcap # 抓取经过任意网卡 8888 上的任意数据包(包括tcp 和udp)tcpdump -i any &#39;port 8888&#39;# 抓取经过任意网卡 协议是tcp 端口是8888 的数据包tcpdump -i any &#39;tcp port 8888&#39;# 抓取经过任意网卡 从源端口 协议是tcp 端口是8888 的数据包tcpdump -i any &#39;tcp src port 8888&#39;# 抓取经过任意网卡 从源端口 协议是tcp 端口是8888 的数据包 或者 从目的端口 协议是udp 端口是9999 的数据包tcpdump -i any &#39;tcp src port 8888 or udp dst port 9999&#39;</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>tcpdump</tag>
      
      <tag>wireshark</tag>
      
      <tag>fiddler</tag>
      
      <tag>https</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2020plan</title>
    <link href="/2020/03/29/2020plan/"/>
    <url>/2020/03/29/2020plan/</url>
    
    <content type="html"><![CDATA[<p>2020Plan</p><a id="more"></a><h1 id="2020-Plan"><a href="#2020-Plan" class="headerlink" title="2020 Plan"></a>2020 Plan</h1><h2 id="基础内容"><a href="#基础内容" class="headerlink" title="基础内容"></a>基础内容</h2><h3 id="TCP-IP"><a href="#TCP-IP" class="headerlink" title="TCP/IP"></a>TCP/IP</h3><p>要求:</p><ul><li>tcp<ul><li>tcp 握手与挥手</li><li>tcp  option</li><li>tcp 拥塞控制</li></ul></li><li>udp<ul><li>udp 编程范式</li></ul></li><li>抓包分析<ul><li>wireshark</li><li>fiddler</li><li>tcpdump</li></ul></li></ul><h2 id="流媒体"><a href="#流媒体" class="headerlink" title="流媒体"></a>流媒体</h2><h3 id="getStats"><a href="#getStats" class="headerlink" title="getStats"></a>getStats</h3><p>要求：</p><ul><li>熟悉getStats 调用链路(2020-08-30)</li><li>熟悉getStats 内部相关数据获取原理(2020-09-30)</li></ul><h3 id="封装与解封装"><a href="#封装与解封装" class="headerlink" title="封装与解封装"></a>封装与解封装</h3><p>要求：</p><ul><li>h264 封装与解封装</li><li>h264 主要数据帧格式</li></ul><h3 id="视频抖动缓存"><a href="#视频抖动缓存" class="headerlink" title="视频抖动缓存"></a>视频抖动缓存</h3><p>要求：</p><ul><li>熟悉接收端抖动缓存的原理</li><li>代码逻辑可修改</li></ul><h3 id="带宽探测"><a href="#带宽探测" class="headerlink" title="带宽探测"></a>带宽探测</h3><p>要求：</p><ul><li>对transport-cc 主要是webrtc 的带宽探测有所了解，了解基本的算法</li></ul><h3 id="抗丢包"><a href="#抗丢包" class="headerlink" title="抗丢包"></a>抗丢包</h3><p>要求：</p><ul><li>了解fec 算法的原理，如何接入</li><li>可自适应的抗丢包策略</li><li>nack 原理以及对应rtcp 包生成细节</li></ul><h3 id="延时"><a href="#延时" class="headerlink" title="延时"></a>延时</h3><p>要求：</p><ul><li>熟悉延时计算方式</li><li>知道延时准确性计算的方法</li></ul><h3 id="licode"><a href="#licode" class="headerlink" title="licode"></a>licode</h3><p>要求：</p><ul><li>搭建一个可用环境</li><li>能进行二次开发</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Git 常用指令</title>
    <link href="/2020/03/28/Git/"/>
    <url>/2020/03/28/Git/</url>
    
    <content type="html"><![CDATA[<p>Git 个人常用命令相关整理</p><a id="more"></a><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h2><h3 id="克隆远端仓库"><a href="#克隆远端仓库" class="headerlink" title="克隆远端仓库"></a>克隆远端仓库</h3><pre><code class="shell"># 在本地生成一个目录git clone gitxxxxURL.git# 在本地生成一个指定目录git clone gitxxxxURL.git myGitDir# clone 远端仓库的指定分支git clone -b branchName gitxxxxURL.git## clone 远端仓库失败情况处理   for the fxxk wargit config --global http.proxy http://127.0.0.1:9666</code></pre><h3 id="分支推送"><a href="#分支推送" class="headerlink" title="分支推送"></a>分支推送</h3><pre><code class="shell"># 将本地当前分支推送到远端指定分支，远端分支不需要加origin 因为前面的origin 已经代表了绑定的远端仓库git push origin HEAD:specificBranch# 本地的分支强制更新远端的指定分支，远端分支的内容有可能被覆盖git push origin HEAD:specificBranch --force# 将远端指定分支删除git push origin :specificBranch</code></pre><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="跟踪远程指定分支"><a href="#跟踪远程指定分支" class="headerlink" title="跟踪远程指定分支"></a>跟踪远程指定分支</h3><p>跟踪后可以直接pull 和push，不需要指定对应的分支名</p><pre><code class="shell"># 生成一个和远端分支名一样的本地分支git checkout --track origin/branchName# 生成一个本地指定分支与远端分支关联git checkout -b localBranchName origin/branchName# 从指定的提交号中生成一个本地分支git checkout -b localBranchName commit_id</code></pre><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code class="shell"># 轻量级标签# 在当前分支的当前commit 上打标签git tag v1.0# 查看所有标签git tag# 给指定commit 打标签git tag v1.1 commitId# 注释标签# -a 标签名  -m 注释git tag -a v1.2 -m &quot;comment&quot; commit# 推tagsgit push origin tagname# 推所有tagsgit push origin --tags# 删除本地的taggit tag -d tagname# 删除远程的taggit push origin :refs/tags/tagname# 查看tag 内容git show tagname# 切换到指定tag 对应的代码git checkout -b localbranchname tagname</code></pre><h2 id="提交处理"><a href="#提交处理" class="headerlink" title="提交处理"></a>提交处理</h2><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><pre><code class="shell"># 这样会生成一个新的commit-id，如果有冲突的话，还需要解决冲突 git cherry-pick commit-id # 中间是两个点.. # 提交一个范围内的commit-id 左开右闭 git cherry_pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt; # 提交一个范围内的commit-id 左闭右闭 git cherry_pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt; </code></pre><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><h3 id="修改某个子模块的url"><a href="#修改某个子模块的url" class="headerlink" title="修改某个子模块的url"></a>修改某个子模块的url</h3><pre><code class="shell"># 修改.gitmodules 文件中，对应模块url 信息# 使用git submodule sync 将url 更新到.git/config 中# 如果第二步骤没有成功的话，手动更新.git/config 文件</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><pre><code class="shell">ssh-keygen -t rsa -b 4096 -C &quot;handsom@guy.com&quot; </code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
