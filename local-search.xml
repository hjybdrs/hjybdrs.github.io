<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>SwitchRemove</title>
    <link href="/2020/10/09/SwitchRemove/"/>
    <url>/2020/10/09/SwitchRemove/</url>
    
    <content type="html"><![CDATA[<p>提高switch 代码的可读性和扩展性</p><a id="more"></a><h1 id="如何干掉又臭又长的switch代码"><a href="#如何干掉又臭又长的switch代码" class="headerlink" title="如何干掉又臭又长的switch代码"></a>如何干掉又臭又长的switch代码</h1><h2 id="提取法"><a href="#提取法" class="headerlink" title="提取法"></a>提取法</h2><p>将case 中的每一个代码块全部抽取为单独的一个函数，但是违背了单一职责原则，多个case 就表明职责的多样性</p><h2 id="跳表法"><a href="#跳表法" class="headerlink" title="跳表法"></a>跳表法</h2><pre><code class="c++">typedef void (*function)(int param);// 存储函数指针，有点类似于nginx 初始化module数组 一样DataProcessor processor[20]={&amp;Kill, &amp;Run, &amp;Jump}</code></pre><h2 id="多态-工厂模式"><a href="#多态-工厂模式" class="headerlink" title="多态+工厂模式"></a>多态+工厂模式</h2><h3 id="创建一个基类"><a href="#创建一个基类" class="headerlink" title="创建一个基类"></a>创建一个基类</h3><pre><code class="c++">class DataProcessor{public:    virtual void Process(int param) = 0;};</code></pre><h3 id="每一个case-实现一个类"><a href="#每一个case-实现一个类" class="headerlink" title="每一个case 实现一个类"></a>每一个case 实现一个类</h3><pre><code class="c++">class Kill : public DataProcessor {public:    void Process(int param) override {        // something    }};</code></pre><h3 id="实现工厂函数"><a href="#实现工厂函数" class="headerlink" title="实现工厂函数"></a>实现工厂函数</h3><pre><code class="c++">DataProcessor* GetProcessor(int param) {    switch(param) {        case Kill:            return new Kill();        case Jump:            return new Jump();        case Run:            return new Run();    }    return nullptr;}</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CodeFix</title>
    <link href="/2020/10/09/CodeFix/"/>
    <url>/2020/10/09/CodeFix/</url>
    
    <content type="html"><![CDATA[<p>好的代码风格</p><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><a href="../SwitchRemove">SwitchRemove</a></p><ul><li>code</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>StringMatch</title>
    <link href="/2020/10/08/StringMatch/"/>
    <url>/2020/10/08/StringMatch/</url>
    
    <content type="html"><![CDATA[<script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Webrtc</title>
    <link href="/2020/09/10/Webrtc/"/>
    <url>/2020/09/10/Webrtc/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 框架梳理</p><a id="more"></a><h1 id="主要内容"><a href="#主要内容" class="headerlink" title="主要内容"></a>主要内容</h1><p><a href="../WebrtcBase">WebrtcBase:基础内容</a></p><ul><li>sdp</li><li>code</li></ul><p><a href="../WebrtcStats">WebrtcStats:数据采集相关</a></p><ul><li>callstack</li></ul><p><a href="../WebrtcCall">WebrtcCall:会话控制管理</a></p><ul><li>callstack</li></ul><p><a href="../WebrtcVideo">WebrtcVideo:视频相关</a></p><ul><li>send recv</li><li>jitterbuffer</li></ul><p><a href="../WebrtcRateControl">WebrtcRateControl:流控</a></p><ul><li>layer</li><li>callstack</li></ul><p><a href="../WebrtcNetwork">WebrtcNetwork:抗弱网相关</a></p><ul><li>layer</li><li>callstack</li></ul><p><a href="../WebrtcBwe">WebrtcBwe:带宽预估相关</a></p><ul><li>layer</li><li>callstack</li></ul><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>webrtc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webrtc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcBase</title>
    <link href="/2020/09/10/WebrtcBase/"/>
    <url>/2020/09/10/WebrtcBase/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 基础内容以及音视频相关整理</p><a id="more"></a><h1 id="WebrtcBase"><a href="#WebrtcBase" class="headerlink" title="WebrtcBase"></a>WebrtcBase</h1><h2 id="WebrtcCode"><a href="#WebrtcCode" class="headerlink" title="WebrtcCode"></a>WebrtcCode</h2><h3 id="序列号判断"><a href="#序列号判断" class="headerlink" title="序列号判断"></a>序列号判断</h3><pre><code class="c++">// 如果seq2 比seq1 要老的话，返回真// 1 2 3 4 5 6 7 8 // seq1 = 6 seq2 = 4 返回真bool AheadOf(uint16_t seq1, uint16_t seq2);</code></pre><h2 id="SDP"><a href="#SDP" class="headerlink" title="SDP"></a>SDP</h2><h3 id="SDP-中的流媒体"><a href="#SDP-中的流媒体" class="headerlink" title="SDP 中的流媒体"></a>SDP 中的流媒体</h3><h4 id="video"><a href="#video" class="headerlink" title="video"></a>video</h4><h5 id="H264"><a href="#H264" class="headerlink" title="H264"></a>H264</h5><p>h264 有四种级别的画质，分别是baseline、extended、main 和high。</p><ul><li>baseline 基本画质，支持I/P 帧</li><li>extended 进阶画质，支持I/P/B/SP/SI 帧(后两个没听说过) </li><li>main     主流画质，支持I/P/B 帧</li><li>high     高级画质</li></ul><p>webrtc 在sdp 交换中有对视频描述如下：</p><pre><code class="shell">a=fmtp:102 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42001fa=fmtp:127 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42001fa=fmtp:125 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=42e01fa=fmtp:108 level-asymmetry-allowed=1;packetization-mode=0;profile-level-id=42e01fa=fmtp:124 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=4d0032a=fmtp:123 level-asymmetry-allowed=1;packetization-mode=1;profile-level-id=640032</code></pre><p>其中profile-level-id=xxxxxx 就是H264 profile和level 的组合，xxxxxx 可以分为三部分，每部分为两个十六进制的数字，从左到右依次为profile_idc(表示画质)、profile_iop和level_idc(码率和分辨率限制)。一般关注第一个和第三个。</p><p><a href="https://blog.csdn.net/liang12360640/article/details/52096499" target="_blank" rel="noopener">https://blog.csdn.net/liang12360640/article/details/52096499</a></p><h3 id="SDP-中的setup"><a href="#SDP-中的setup" class="headerlink" title="SDP 中的setup"></a>SDP 中的setup</h3><p>a=setup 主要是表示dtls 协商中角色的问题，谁是客户端，谁是服务器。</p><pre><code class="shell"># 既可以是服务端 也可以是客户端a=setup:actpass# 客户端a=setup:active# 服务端a=setup:passive</code></pre><p><a href="https://blog.csdn.net/glw0223/article/details/91871718" target="_blank" rel="noopener">https://blog.csdn.net/glw0223/article/details/91871718</a><br><a href="https://blog.csdn.net/m0_37263637/article/details/96355737" target="_blank" rel="noopener">https://blog.csdn.net/m0_37263637/article/details/96355737</a></p><h3 id="SDP-中的-trickle"><a href="#SDP-中的-trickle" class="headerlink" title="SDP 中的 trickle"></a>SDP 中的 trickle</h3><pre><code class="shell">#通知对端支持trickle，即sdp里面描述媒体信息和ice候选项的信息可以分开传输a=ice-options:trickle</code></pre><p><a href="https://www.jianshu.com/p/61e3c9e13456" target="_blank" rel="noopener">https://www.jianshu.com/p/61e3c9e13456</a></p><h3 id="SDP-中的-音视频描述"><a href="#SDP-中的-音视频描述" class="headerlink" title="SDP 中的 音视频描述"></a>SDP 中的 音视频描述</h3><pre><code class="shell">m=video 9 UDP/TLS/RTP/SAVPF 96 97 98 99 100 101 102 122 127 121 125 107 108 109 124 120 123 119 114 115 116</code></pre><p>AVP     ==&gt; audio video profile 不会启用rtcp 反馈，也不会根据rtcp反馈动态调整码率<br>AVPF    ==&gt; audio video profile feedback<br>SAVPF   ==&gt; safe audio video profile feedback</p><p><a href="https://segmentfault.com/a/1190000020794391" target="_blank" rel="noopener">https://segmentfault.com/a/1190000020794391</a></p><h3 id="SDP-的格式"><a href="#SDP-的格式" class="headerlink" title="SDP 的格式"></a>SDP 的格式</h3><p>webrtc 中，unified plan、plan B、plan A 是SDP 中多路媒体略的协商方式，在72 版本中，Chrome 默认使用unified plan 替换了Plan B。<br>在浏览器端，打开chrome://webrtc-internals 可以查看到PeerConnection 使用的sdp 协商方式。</p><pre><code class="txt">https://webrtc.github.io/samples/src/content/peerconnection/pc1/, { iceServers: [], iceTransportPolicy: all, bundlePolicy: balanced, rtcpMuxPolicy: require, iceCandidatePoolSize: 0, sdpSemantics: &quot;unified-plan&quot; },</code></pre><ul><li>plan B : sdp 中，一个m 行描述多路media stream 以，msid 作为区分<pre><code class="shell">a=group:BUNDLE audioa=msid-semantic: WMS stream-id-2 stream-id-1m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:audio...a=rtpmap:103 ISAC/16000...a=ssrc:10 cname:cnamea=ssrc:10 msid:stream-id-1 track-id-1a=ssrc:10 mslabel:stream-id-1a=ssrc:10 label:track-id-1a=ssrc:11 cname:cnamea=ssrc:11 msid:stream-id-2 track-id-2a=ssrc:11 mslabel:stream-id-2a=ssrc:11 label:track-id-2</code></pre></li><li>unified plan: 一个m 行对弈一个media stream<pre><code class="shell">a=group:BUNDLE 0 1a=msid-semantic: WMSm=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:0...a=sendrecva=msid:- &lt;track-id-1&gt;...a=rtpmap:103 ISAC/16000...a=ssrc:10 cname:cnamea=ssrc:10 msid: track-id-1a=ssrc:10 mslabel:a=ssrc:10 label:track-id-1m=audio 9 UDP/TLS/RTP/SAVPF 111 103 104 9 0 8 106 105 13 110 112 113 126...a=mid:1...a=sendrecva=msid:- track-id-2...a=rtpmap:103 ISAC/16000...a=ssrc:11 cname:cnamea=ssrc:11 msid: track-id-2a=ssrc:11 mslabel:a=ssrc:11 label:track-id-2</code></pre></li></ul><p><a href="https://juejin.im/post/6844903792001974280" target="_blank" rel="noopener">https://juejin.im/post/6844903792001974280</a></p><h2 id="H264-1"><a href="#H264-1" class="headerlink" title="H264"></a>H264</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>H264 中，句法元素从大到小被组织为序列(GOP)、图像、切片、宏块、子宏块共五个层次。</p><p>一个序列 = n 个图像帧<br>一个帧 = n 个切片<br>一个切片 = n 个宏块<br>一个宏块 = n 个子宏块  </p><h3 id="码流结构"><a href="#码流结构" class="headerlink" title="码流结构"></a>码流结构</h3><p>码流结构从功能上分为两层：</p><ul><li>VCL(视频编码层)<br>  包括核心压缩引擎和快，宏块和片的语法级别定义，设计目标是尽可能独立于网络进行高效的编码。即编码处理的输出，表示被压缩编码后的视频数据序列</li><li>NAL(网络提取层)<br>  负责将VCL 产生的比特字符串适配到各种各样的网络和多元环境中，覆盖所有片级以上的语法级别</li></ul><p><img src="./media_foramt.png" srcset="/img/loading.gif" alt="media_format"></p><h3 id="NALU-HEADER"><a href="#NALU-HEADER" class="headerlink" title="NALU HEADER"></a>NALU HEADER</h3><pre><code class="txt">+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|   Type  |+---------------+</code></pre><p>NALU HEADER 数据位描述：</p><ul><li>F 在规范中一直为0</li><li>NRI 表明这个NALU 的重要性</li><li>Type 表明NALU 类型：<ul><li>1- 23 单个NAL 数据包</li><li>其他的组包格式</li></ul></li></ul><h3 id="几种常见的NALU-类型"><a href="#几种常见的NALU-类型" class="headerlink" title="几种常见的NALU 类型"></a>几种常见的NALU 类型</h3><p>主要介绍PPS、SPS和SEI:</p><ul><li><p>SPS(Sequence Parameter Sets，序列参数集):是H.264码流序列的第一个NALU。SPS 语法单元存放一个视频序列的共同特征。从SPS 中能获取图像的宽和高数据信息。如果SPS 丢失的话，解码大概率出现失败的情况。</p></li><li><p>PPS(Picture Parameter Sets，图像参数集): 是H.264码流序列的第二个NALU。PPS 语法单元存放一个视频图像的典型特征。</p></li><li><p>SEI(Supplemental Enhancement Information，补充增强信息):提供了向视频码流中加入额外信息的方法。</p></li></ul><h3 id="webrtc-h264-pack"><a href="#webrtc-h264-pack" class="headerlink" title="webrtc h264 pack"></a>webrtc h264 pack</h3><h4 id="STAP-A"><a href="#STAP-A" class="headerlink" title="STAP-A"></a>STAP-A</h4><pre><code class="txt">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                          RTP Header                           |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|STAP-A NAL HDR |         NALU 1 Size           | NALU 1 HDR    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                         NALU 1 Data                           |:                                                               :+               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|               | NALU 2 Size                   | NALU 2 HDR    |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                         NALU 2 Data                           |:                                                               :|                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                               :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+STAP-A NAL HDR 格式如下+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+其中F 和NRI 取NALU 1 的F 和NRI。 TYPE 默认都是24</code></pre><p>eg:<br>原始264 码流(带start-code):<br>sps [0  0  0  1  103  77  64  41  149  144  5  0  91  176  17  0  0  3  3  232  0  1  212  192  132]  pps [0  0  0  1  104  235  143  32] idr [0  0  0  1  101  184  4  11]</p><p>编码出来后的数据:<br>[120  0  21  103  77  64  41  149  144  5  0  91  176  17  0  0  3  3  232  0  1  212  192  132]<br>STAP-A NAL HDR ==&gt;103 ==&gt; 0110 0111 ==&gt; 011(1 1000 = 24) ==&gt; 01111000(120)<br>0 21 =&gt; nalu 1 len 21<br>[0  4  104  235  143  32]<br>0 4  =&gt; nalu 2 len 4</p><h4 id="FU-A"><a href="#FU-A" class="headerlink" title="FU-A"></a>FU-A</h4><pre><code class="txt">0                   1                   2                   30 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+| FU indicator  |   FU header   |                               |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+                               ||                                                               ||                         FU payload                            ||                                                               ||                               +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+|                               :...OPTIONAL RTP padding        |+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+Figure 14.  RTP payload format for FU-AThe FU indicator octet has the following format:+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|F|NRI|  Type   |+---------------+Values equal to 28 and 29 in the type field of the FU indicator octet identify an FU-A and an FU-B, respectively. The use of the F bit is described in [Section 5.3].  The value of the NRI field MUST be set  according to the value of the NRI field in the fragmented NAL unit.The FU header has the following format:+---------------+|0|1|2|3|4|5|6|7|+-+-+-+-+-+-+-+-+|S|E|R|  Type   |+---------------+S:     1 bit          When set to one, the Start bit indicates the start of a          fragmented NAL unit.  When the following FU payload is not the          start of a fragmented NAL unit payload, the Start bit is set          to zero.E:     1 bit          When set to one, the End bit indicates the end of a fragmented          NAL unit, i.e., the last byte of the payload is also the last          byte of the fragmented NAL unit.  When the following FU          payload is not the last fragment of a fragmented NAL unit, the          End bit is set to zero.R:     1 bit          The Reserved bit MUST be equal to 0 and MUST be ignored by the          receiver.Type:  5 bits          The NAL unit payload type was the fragmentation nalu type. </code></pre><p>eg: 编码一个I 帧 第一个字节为0x65=101，进行了分组<br>原始数据为<br>0x65 =&gt; 0110-0101<br>[101  184  4  11  255]</p><p>FU-idicator =&gt; 011 + 28(11100) =&gt; 01111100(0x7c)= 124<br>first fu-a FU-header =&gt; 100 + (nalu-type[00101])  =&gt; 10000101(0x85) = 133<br>middle fu-a FU-herader =&gt; 000 + (nalu-type[00101]) =&gt; 00000101(0x05) = 5<br>last fu-a FU-herader =&gt; 010 + (nalu-type[00101]) =&gt; 01000101(0x45) = 69<br><strong>不带naluHeader(101)的内容(0copy 客户端接收异常原因)</strong><br>第一个FU-A<br>[[124  133]  184  4  11  255]<br>中间的FU-A<br>[[124  5]  177  244  72  95]<br>最后一个FU-A<br>[[124  69]  212  53  47  240]</p><h4 id="workflow"><a href="#workflow" class="headerlink" title="workflow"></a>workflow</h4><pre><code class="c++">// 初始化packetizer 的最大包长度、和最后一个包冗余空间RtpPacketizer packetizer(maxpayload_len, reduction_len);// 输入一帧数据和nalu 分割信息int num_packets = packetizer-&gt;setPayload(data, len, frag);void setPayload(data, len, frag) {    // 根据frag 将一帧数据分为多个nalu，并塞入到input_fragments_ 中    input_fragments_.push_back(Fragment());    // 根据长度、打包类型进行打包    GeneratePackets();    return num_packet_left;}void GeneratePackets() {    for(input_fragments) {        case SingleNalUnit: packetSignaleNalu()        case NonInterleaved: PacketizeFuA() or PacketizeStapA()    }}// 一个nalu 拆为多个packetsvoid PacketizeFuA() {    // 1: 判断是否最后一个nalu，添加对应的 extenlen(头部扩展长度)    // 2: 需要发送的nalu的nalu header 不用保存，在nalu-header 保留nalu header 类型(fragment.length = naluHeadLen)    // 3: 每个包的负载大小为最大减去Fu-A 协议长度(indicator + header) 2 Byte    // 一个 nalu 14 bytes 包最大负载为5字节     // (14+(5-1))/5 = 3(packets)      // 14 / 3 = 4(bytes per packets)     // 14 % 3 = 2(first packets) 2 3 3 3 3    // 4: 计算分为多少个包、计算每个包的长度    // 5: 将一个nalu 划分为多个PacketUnit 塞进 packets_}// 多个nalu 合并为一个packetsvoid PacketizeStapA() {    // 循环(当前空间足够，即使是最后一个nalu 加上extlen 也足够)    // 将多个nalu 塞到多个PacketUnit 中，标识第一个包和最后一个包即可。}</code></pre><h2 id="RTP-RTCP协议"><a href="#RTP-RTCP协议" class="headerlink" title="RTP/RTCP协议"></a>RTP/RTCP协议</h2><p>分类：</p><p>RTP 关乎数据传输</p><p>RTCP 关乎数据传输控制</p><h3 id="RTP-协议和头部扩展"><a href="#RTP-协议和头部扩展" class="headerlink" title="RTP 协议和头部扩展"></a>RTP 协议和头部扩展</h3><h4 id="首部格式"><a href="#首部格式" class="headerlink" title="首部格式"></a>首部格式</h4><p>RTP 分组的首部格式：</p><img src=" ./RTP分组首部格式.png" srcset="/img/loading.gif" style="zoom:67%;" /><h4 id="包头信息"><a href="#包头信息" class="headerlink" title="包头信息"></a>包头信息</h4><p>包头各个字段信息如下所示：</p><img src="./RTP包头信息.png" srcset="/img/loading.gif" style="zoom:67%;" /><ul><li><p>版本号(V):2比特，标识rtp 版本</p></li><li><p>填充位(P):1比特，如果设置该位置的话，rtp包的尾部就包含附加的填充字节</p></li><li><p>扩展位(X):1比特，如果设置该位置的话，RTP 固定头部(12字节)后就跟着一个扩展头部</p></li><li><p>CSRC计数器(CC):4 比特，在固定头部后跟随的CSRC 的数目</p></li><li><p>标记位(M):1比特，由具体的解释文档说明，对于H264来说标识一帧的结束</p></li><li><p>荷载类型(PT):7比特，标识RTP荷载的类型</p></li><li><p>序列号:2字节，每发送一个RTP 数据包，序列号增加1。接收端根据此检测丢包和重建包序列</p></li><li><p>时间戳:4字节，记录一个时间戳</p></li><li><p>同步源标识符(SSRC):4字节，随机算法生成</p></li><li><p>贡献源列表(CSRC):4字节，0~15个CSRC，具体数目由CSRC 计数器(CC)计算生成。</p></li></ul><h4 id="头部扩展"><a href="#头部扩展" class="headerlink" title="头部扩展"></a>头部扩展</h4><p>  头部扩展如下：</p>  <img src="./RTP头部扩展.png" srcset="/img/loading.gif" style="zoom:67%;" /><p>如上所述，如果扩展位置为1，则一个长度可变的头扩展部分被加到RTP 固定头之后。头扩展包含16位比特的长度与，指示扩展项中32比特字的个数，但是不包含4字节扩展头的长度。为了实现特定的不同扩展，其中扩展项的前16位比特用以识别标识符或者参数。</p><p><strong>有且仅有一个头部扩展</strong></p><blockquote><p><a href="https://blog.csdn.net/machh/article/details/51868569" target="_blank" rel="noopener">https://blog.csdn.net/machh/article/details/51868569</a></p></blockquote><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcBWE</title>
    <link href="/2020/09/10/WebrtcBWE/"/>
    <url>/2020/09/10/WebrtcBWE/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 带宽预估以及拥塞控制相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcNetwork</title>
    <link href="/2020/09/10/WebrtcNetwork/"/>
    <url>/2020/09/10/WebrtcNetwork/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 弱网对抗相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcRateControl</title>
    <link href="/2020/09/10/WebrtcRateControl/"/>
    <url>/2020/09/10/WebrtcRateControl/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 流控相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcVideo</title>
    <link href="/2020/09/10/WebrtcVideo/"/>
    <url>/2020/09/10/WebrtcVideo/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 视频相关整理</p><a id="more"></a><p><img src="./video_receive_render.png" srcset="/img/loading.gif" alt="video_receive_decoder"></p><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcCall_PeerConnection</title>
    <link href="/2020/09/10/WebrtcCall_PeerConnection/"/>
    <url>/2020/09/10/WebrtcCall_PeerConnection/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 会话控制管理以及PeerConnection相关整理</p><a id="more"></a><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>WebrtcStats</title>
    <link href="/2020/09/10/WebrtcStats/"/>
    <url>/2020/09/10/WebrtcStats/</url>
    
    <content type="html"><![CDATA[<p>Google Webrtc 统计数据相关整理</p><a id="more"></a><h1 id="getStats"><a href="#getStats" class="headerlink" title="getStats"></a>getStats</h1><p>based on commit: d4089cae47334a4228b69d6bb23f2e49ebb7496e</p><h2 id="call-chain"><a href="#call-chain" class="headerlink" title="call-chain"></a>call-chain</h2><img src="./call_chain.jpg" srcset="/img/loading.gif" style="zoom:50%;" /><h2 id="Field"><a href="#Field" class="headerlink" title="Field"></a>Field</h2><ul><li>frameRate: receiveFps、decodeFps、dropFps、renderFps</li><li>bps: rtpBps(ori + fec)、rtxBps、payLoadBps(%)</li><li>transport: rtt、jitterBufferDelay、jitterBufferEmittedCount(from packet queue to jitterBufferDelay and Count)</li><li>rtcp: pliCount、nackCount</li></ul><p>base on these IDL:</p><ul><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcrtpstreamstats" target="_blank" rel="noopener">RTCRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcreceivedrtpstreamstats" target="_blank" rel="noopener">RTCReceivedRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcinboundrtpstreamstats" target="_blank" rel="noopener">RTCInboundRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcremoteinboundrtpstreamstats" target="_blank" rel="noopener">RTCRemoteInboundRtpStreamStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcsctptransportstats" target="_blank" rel="noopener">RTCTransportStats</a></li><li><a href="https://www.w3.org/TR/webrtc-stats/#dom-rtcicecandidatepairstats" target="_blank" rel="noopener">RTCIceCandidatePairStats</a></li></ul><p><a href="https://juejin.im/post/6844903792001974280" target="_blank" rel="noopener">https://juejin.im/post/6844903792001974280</a><br><a href="https://blog.csdn.net/Chengzi_comm/article/details/89526935" target="_blank" rel="noopener">https://blog.csdn.net/Chengzi_comm/article/details/89526935</a></p><h2 id="二次开发"><a href="#二次开发" class="headerlink" title="二次开发"></a>二次开发</h2><img  src=http://www.plantuml.com/plantuml/svg/lLJRQW8n47tFLmIVse9_84AnGejTA2ZjewIxeuQkoPADjb3yz-RYhfDaLx4F1a7DEScSEJCJKh7yYws13hxXK-byG7u9DIilMLtJTrw0pA3WRB9XGa3fCC-mQozvGTUWvvhf-kxUxH_mUSbpkFeyCPzMrlnfrcXgzzoDSws0RGVHZJuk8hJ8YMENOqp5cWluKAogGD4bkBy1hH7eZ7WHAtaKcIImOGhEu8-xWiVd3-slBlM1jfuaalAOlUNURbwcrLPnI8kBPMdC2h-X9GHzXVNsXZJrZYppAJ9XwEfSnNrFcBos7HtIgfF2DYIlDS_hLDqfgalnvb6TSJUFch6V3BGoh9wOpul56rrkjAxETNXJq-dhZ8v6arBkYl6uvqOVsDvxUMOcKgmIJ-W_J36T99kQ7eSf2mZO_au2xefEmibAAoFq5DLbmRUWalV2Fu-4f4Cz7CgkfoCTwnuYwNWJM-hHAO87pQ7O-23p60nyYq62YsF1OA1ZC9Yx60p68mPnJDUmPlS1zpQgpR24bJOeFlC7><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Videojitterbuffer</title>
    <link href="/2020/09/08/videojitterbuffer/"/>
    <url>/2020/09/08/videojitterbuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="JitterBuffer"><a href="#JitterBuffer" class="headerlink" title="JitterBuffer"></a>JitterBuffer</h1><p>based on:m74(commit cc1b32545db7823b85f5a83a92ed5f85970492c9)</p><h2 id="RtpVideoStreamReceiver"><a href="#RtpVideoStreamReceiver" class="headerlink" title="RtpVideoStreamReceiver"></a>RtpVideoStreamReceiver</h2><img  src=http://www.plantuml.com/plantuml/svg/hLXBZzj47B_xKupsj8tOIuMu15LgqmSHWbJPbgiriIUBQUmOUpRigbG2sg85qbKFfQ9KhNWKRI-4xQK2MlWqTNPxuYimdXaxy_YFtI9oI9oPt__zcF_OIt5m1MyHjFO96MKqMFEkUeXzy2Yd6Gue2YOupz5P4an34lPZ1ktXoMJ4g910bf_PD0ebPlr45nqV_7pqm-V5OhxSkrtStZ_w_aPn_-7nuNMEl-P10Zw8GZ8L738dOtrvIBQYd99CRFUcSJeXjDPk7LAvWuAHP2FL4DBVEVdMcmxXlOnWMWjtKVMPS9FoVz4FTFp6njGKBj2g7HiRdvxIt6eYkCuSfIowWxCP9LVw2RDdZ0FoDbywd-6Od3Bj7YHytN2PmV9SqfvGWqH5DVDxdz5laWG8OBbQxZRJlqjskTP3yl4soIdCIcvMs6QEWwGAEGUxZTHWpJmtTvC0ZoQ4CMb0bQ8sAQRvO9IJR6RRCKY6b5vEGpknBHjEvpc9cSImnGWTPt2jUyn74MK9DDeUZqcsfZ2HQTPxxr8KHybMPPx2OeNY0ivm5Wg7ybFJTz0iY2b_zBjkJXUPMeI2h5o6bmNQHSn1ssnX5mrfAcg3iYuH3qb0efaiDCq__OG5WWfvQX-h0UUZH0ZArMr5OsSaobwW6WAwQqZO3aa2KihXnhgz0jja-4TpNQhyyNNZGEbZ_cCWMuAdvMvQUnAzUBOVadXx1ottVrdUURhyzd1vQm5I2KF2YtXtCiNXMKonfCzeMinl5a--UFdW9tPo5Sy_4rpOek8bTv7K-cWT4ggvLCy0xJ0PqXsfed2yGWyBwA2OX17sSxROHSNYuSjxDr_y_dLn-6JvtMyjYVbwdfHwEXA3do2kz9I4XccS1BQgLPA3pBEoiYoC1ZU0cUccGKA26Z6MiHT8Gh8eUEMvHPjoGl7hQycW8KfrB2c62d90Q6pFgydiGtRIo-ditcCnb1LxXyjV7nMFRlppV5vyUOlzLSolD5b-TN3yurpwBAc6YKfdXnOyNj00unasz1WYA2lo3CwLmh5Cxw0BXChdTIxh3PTmPP8ovx5pE-mhmPEAqGe621JZt-aax2SHNL4KU_UBPtyMVpmjzXuK1zyKyxkrLvtCK4ep7mww1PMHrnpJukl_Gb06kguABIZgZf9EBLtQYcKfE2YVD0oea7IDM2rFMNYQbahLOpHZPoo9q3DBHaWqGo2VMTuVtNbylFZxwA-5AVcrBXzcCgdrswbA_4HBYMjX0FteXCc1gQNPwK1bWW9sZQI0hWEMoys6moLScefM0VXE7CKo3LPD61WTrGk85i6hUbEjStMc_lExhwYNVSFfe8XTFdX-SvP-piNxrb6hYXSgglht9HF5WfMNDOkKvD0j5HSvo-SANZaXtPo59o5zzCi4h75rbmHENQ1ZM2CCiAkwtouoTd_9j55P7Vl7gsSbmew3EmEN_QuZVv0pWu3GpAmblHdAife5LgU4l1pPQy1mO0TRzwixZHhWxWwWeDGGDE6SunjCuZaIn9brZNZenK8pnUhLGJCEV4NGJE9u1z1CL5tocr7M9T-xvlqB><h2 id="VideoReceiver"><a href="#VideoReceiver" class="headerlink" title="VideoReceiver"></a>VideoReceiver</h2><h2 id="VideoStreamDecoder"><a href="#VideoStreamDecoder" class="headerlink" title="VideoStreamDecoder"></a>VideoStreamDecoder</h2><h2 id="VCTiming"><a href="#VCTiming" class="headerlink" title="VCTiming"></a>VCTiming</h2><h2 id="PacketBuffer"><a href="#PacketBuffer" class="headerlink" title="PacketBuffer"></a>PacketBuffer</h2><p>作用： 包缓存，返回数据帧(如何定义帧？)到RtpVideoStreamReceiver</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[PacketBuffer]<ul><li>size(512-2048个pkt)</li><li>buffer<ul><li>sequence_buffer 保存pkt信息</li><li>data_buffer 保存真实pkt</li></ul></li><li>InsertPacket() 插入数据包</li><li>UpdateMissingPackets() 更新丢失pkt，用于检测P帧前的gap</li><li>FindFrames() 查找可用帧，并回调</li><li>PotentialNewFrame() 查找潜在连续帧</li><li>PaddingReceived() 更新padding</li></ul></li></ul></blockquote><pre><code class="c++">void FindFrames(uint16_t seq) {    for(最多找一圈，并且序列号是连续) {        if(currentPacket == frame_end) {            while(1) {            }            if(is_264) {                // 如果不是关键帧，当前帧前面有丢失的数据包                // 重置data_buffer 相关数据包的状态                if(!iskeyframe &amp;&amp; gap()){                    reset_databuffer_status();                }            }            missing.erase();            found_frames.insert();        }    }}</code></pre><p>可以考虑的两个点：</p><ul><li>nackCount</li><li>max(min)recvtime</li></ul><h2 id="RtpFrameReferenceFinder"><a href="#RtpFrameReferenceFinder" class="headerlink" title="RtpFrameReferenceFinder"></a>RtpFrameReferenceFinder</h2><p>作用：找到每一个帧的参考帧，关键帧是自参考，后续的GOP内的每一帧都参考上一帧，GOP 内有序。</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[RtpFrameReferenceFinder]<ul><li>ManageFrame()<ul><li>ManageFrameInternal()</li><li>ManageFramePidOrSeqNum()</li></ul></li><li>PaddingReceived()</li><li>UpdateLastPictureIdWithPadding()</li><li>RetryStashedFrames()</li><li>ClearTo()</li></ul></li></ul></blockquote><pre><code class="c++">// 在调用这个前插入了一个picture_id 针对h264 是否存在？void ManageFramePidOrSeqNum() {    // map&lt;last_seq, pair&lt;seq, seq&gt;&gt; last_seq_num_gop_    // 1. 如果是关键帧，则插入关键帧 到last_seq_num_gop_    // 2. 如果last_seq_num_gop_ 为空，则缓存这个帧，表明当前并没有关键帧存在    // 3. 删除较老的关键帧信息(当前seq-100)，至少保存一个关键帧序列号    // 4. 如果当前帧所依赖的关键帧已经不存在了，直接丢弃。并找到当前帧所依赖的关键帧的序列号    // 5. 如果是P帧的话，判断帧第一个包序列号是否和对应关键帧的最后一个序列号(会随着帧连续不断修改)相等，否则返回缓存。不相等说明中间有gap    // 6. 更新当前插入帧的VideoFrameLayer中的pic_id 为最后一个包seq，更新是否需要依赖，并且依赖的帧的信息    // 7. 更新当前帧所依赖关键帧序列号，作为下一帧的依赖，和1 相互呼应(在此已经保证是连续的了，5已说明)    // 8. UpdateLastPictureIdWithPadding()    // 9. 更新最后一个序列号考虑padding 场景}void UpdateLastPictureIdWithPadding(seq) {    // 1.如果当前序列号比关键帧序列号还老，返回    // 2.获取当前seq 所依赖的关键帧信息    // 3.如果有因padding 包存在可以使得序列号连续的，更新包的序列号    // 4.极端情况下，清除关键帧信息和状态}void RetryStashedFrames() {    // 有两种情况可以尝试从stashed 中查找    // a. 缓存帧遍历查找    // b. 因padding 包的存在，可以使得序列号连续    // 1. 从缓存帧处遍历，查看是否能找到连续的帧}</code></pre><h2 id="FrameBuffer"><a href="#FrameBuffer" class="headerlink" title="FrameBuffer"></a>FrameBuffer</h2><p>作用：GOP间 内有序。</p><blockquote class="pullquote mindmap mindmap-md"><ul><li>[FrameBuffer]<ul><li>ValidReferences() 判断帧之间的参考是否正确</li><li>UpdateFrameInfoWithIncomingFrame() 更新frameinfo 和其他frame的info<ul><li>遍历当前帧的依赖帧<ul><li>如果上一次解码的帧比依赖帧更新，依赖帧永远不会被解码 rt=&gt;false</li><li>在frames 中查找依赖帧，并判断依赖帧是否连续</li></ul></li><li>inter_layer_predicted only vp9 support</li><li>未连续参考帧和未解码参考帧计数器</li><li>判断依赖帧是否连续，并且更新依赖帧被哪些帧所依赖(反向依赖关系)</li></ul></li><li>PropagateContinuity()<ul><li>通过BFS来进行连续性的传播，还有个依赖的就是上一层建立的反向依赖关系</li></ul></li><li>Public<ul><li>Start() 随着videoreceivestream start</li><li>Stop() 随着stop</li><li>SetProtectionMode()</li><li>Clear()</li><li>InsertFrame() 插入数据帧</li><li>UpdateRtt() 根据rtt 调整jitterEsmitor 策略</li><li>NextFrame() 弹出数据帧<ul><li>keyframe-&gt;200ms deltaframe-&gt;3000ms</li><li>遍历缓存帧<ul><li>没有连续或者还有依赖的未解码帧</li><li>当前帧并不为目前所需要的关键帧</li><li>获取上一次解码帧的rtp tmp 比较筛选出跳帧的情况</li></ul></li></ul></li></ul></li></ul></li></ul></blockquote><pre><code class="c++">bool ValidReferences() {    // 1. 判断pic_id，pic_id 就是当前帧最后一个包的seq    // 2. 判断pic_id 和依赖的seq是否符合规定      // a. 如果依赖的seq 比当前帧的seq 还大，不符合      // b. 如果连续依赖的seq 之间相等，不符合    // 3. 应该是判断时域分层内容}int InsertFrame() {    // 1. 统计回调    // 2. 最近连续帧seq(当前帧的最后一个seq)    // 3. ValidReferences()帧有效性判断    // 4. 如果当前帧数超过最大容量       // a. 如果当前关键帧，清空队列，继续       // b. 非关键帧，直接返回最近连续帧seq 直接丢弃会不会有问题？    // 5. 获取最近解码帧seq 和解码时间戳,如果当前帧seq 比最近解码帧seq 小       // a. 如果是关键帧，并且当前帧的时间更新，清空队列，继续       // b. 其他情况，直接返回最近连续帧seq 直接丢弃会不会有问题？    // 6. 出现跳帧情况，比第一个小，比最后一个大的情况出现，清空，继续    // 7. 尝试插入，如果之前存在，直接返回最近解码帧的seq    // 8. UpdateFrameInfoWithIncomingFrame()    // 9. 判断当前帧是否因为重传导致了延时，nack_count &gt; 0 更新timing    // 10.如果当前帧的参考帧都到齐了       // a. PropagateContinuity()       // b. 计算最大限度可解码帧seq     // 11. 唤醒解码线程，并返回最大限度可解码帧seq}</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    <categories>
      
      <category>webrtc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>jitterbuffer</tag>
      
      <tag>pakcetbuffer</tag>
      
      <tag>referencefinder</tag>
      
      <tag>framebuffer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ProjectCompile</title>
    <link href="/2020/09/04/ProjectCompile/"/>
    <url>/2020/09/04/ProjectCompile/</url>
    
    <content type="html"><![CDATA[<p>Google Chromium 和 Webrtc 编译调试</p><a id="more"></a><h1 id="项目编译"><a href="#项目编译" class="headerlink" title="项目编译"></a>项目编译</h1><h2 id="Requirements"><a href="#Requirements" class="headerlink" title="Requirements"></a>Requirements</h2><pre><code class="shell"># depot_toolsgit clone https://chromium.googlesource.com/chromium/tools/depot_tools.git# export toolsexport PATH=&quot;$PATH:/path/to/depot_tools&quot;# fetch# 查看哪些项目代码可以获取fetch --help# 获取对应代码fetch webrtc</code></pre><h2 id="Webrtc"><a href="#Webrtc" class="headerlink" title="Webrtc"></a>Webrtc</h2><pre><code class="shell"># 创建文件夹 拉取代码  同步代码mkdir webrtc-checkout &amp;&amp; cd webrtc-checkout &amp;&amp; fetch webrtc &amp;&amp; gclient sync# 生成ninja projectgn gen out/Default# 编译ninja -C out/Default# 使用ccache 加速编译# out-gn 是编译生成的目录 类似cmake 的build 文件夹# https://chromium.googlesource.com/chromium/src/+/master/docs/ccache_mac.md# 针对webrtc 不能在args.gn 文件中设置 is_component_build = true# 可以在args.gn 文件中查看到对ccache 的设置 cc_wrapper = &quot;ccache&quot;gn gen out-gn --args=&#39;cc_wrapper=&quot;ccache&quot;&#39;ninja -C out-gen# https://webrtc.github.io/webrtc-org/native-code/development </code></pre><h2 id="Chromuim"><a href="#Chromuim" class="headerlink" title="Chromuim"></a>Chromuim</h2><pre><code class="shell"># 创建文件夹 拉取代码mkdir chrome &amp;&amp; cd chrome &amp;&amp; fetch chromium# 生成ninja projectgn gen out/Default# 编译ninja -C out/Default# 生成的可执行文件在 Chromium.app/Contents/MacOS# https://chromium.googlesource.com/chromium/src/+/master/docs/mac_build_instructions.md# 切换到指定分支编译 # 拉取代码 拉取tagsgit fetch &amp;&amp; git fetch --tags# 根据tag 切换到指定的taggit checkout -b localbranch tagname# 更新所有submodule 的代码gclient sync --with_branch_heads --with_tags# chromium 对应分支信息# https://chromiumdash.appspot.com/branches# http://www.chromium.org/developers/how-tos/get-the-code/working-with-release-branches# https://blog.csdn.net/chinabinlang/article/details/100122002# 使用ccache 加速编译过程# https://chromium.googlesource.com/chromium/src/+/master/docs/ccache_mac.md# 开启日志./chrome --enable-logging --v=1# https://blog.csdn.net/foruok/article/details/71080012# 日志位置 分两种情况# 如果是安装版本的chrome 的话~/Library/Application Support/Google/Chrome/chrome_debug.log# 如果是自己编译的chromium 的话~/Library/Application Support/Chromium/chrome_debug.log</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>chromuim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PeerConnection</title>
    <link href="/2020/08/02/PeerConnection/"/>
    <url>/2020/08/02/PeerConnection/</url>
    
    <content type="html"><![CDATA[<p>和PeerConnection 有关的一切</p><a id="more"></a><h1 id="PeerConnection"><a href="#PeerConnection" class="headerlink" title="PeerConnection"></a>PeerConnection</h1><p>based on commit: d4089cae47334a4228b69d6bb23f2e49ebb7496e<br>useful file: </p><ul><li>conductor.cc(examples/peerconnection/client)</li><li>simple_peer_connection.cc(examples/unityplugin)</li></ul><h2 id="拉取webrtc-代码"><a href="#拉取webrtc-代码" class="headerlink" title="拉取webrtc 代码"></a>拉取webrtc 代码</h2><p>拉取分支</p><pre><code class="shell">git clone https://chromium.googlesource.com/external/webrtc#设置git config#在 .git/config 文件中的  `[remote &quot;origin&quot;]` 节中添加以下内容：# fetch = +refs/branch-heads/*:refs/remotes/origin/*git pull# 拉取远端tagsgit fetch --tags</code></pre><img  src=http://www.plantuml.com/plantuml/svg/dLTTRzn457tVNp7gGxIxogeelDKbKjc2L8bAKLQKHyjhJnEhwmyyinjLW9G2gHO4H9Le12LGYbIAGEm6zO6aRSYFOUrrdlWBp7ZizNpP6_1BrkDxxznxvjnp9utGikzOMn1SiYFNlWFnfSO73K0UguzmPDaOs0CB8N0JEgxLtRPy7mu0iw1FFmW6u9hZzA3lz704BQzf1px2WBriM97beHM0mfOX-cn2BnX1pcte-lZrDHC3X29RjYOxR49xz3zsuDnqEtpKq1LxotLW85NCcwlVEvqFrmMCgkEIZA1BIi-IaW8pi_TWVnFRMkEYGlLZ6w3ihsaecOf1EfsWSWS-2_Nh6fS02Zm8HjPW2941veUFuyaFyqUVZgXFn7nOElN9h37WwXFXaYtviWouQgfoZ6WPuFBbClju_5tyyaKTj-iT47QkNF6iy6h1jDLAeDlh88V9P3WXyu9Xocn834HUr00yC9LSacXGq5RouG2lS90zX8vG6gMwBTxojrmVtl0nZ6vRDfIvpWTfWox924D-hTa2Ru3NZ5fEi2t-UsHZMUy7sX9gp9Ma51ZpN4iKvU2L8bq3PE3QKFgy0aPqbOTlaRPgIbShaUu6NXWWDqTF1RjsToBLKKJ2NpI5XRt4TosNAEIwx38FRTgbdby4zpSj15N14OdbqJVJ5ZcrQFUXxxu_X6Q8ewkysxhePjQDHNEdSZ2cHv_Cl_v520M8V4bYACRkGKmdA8RTWDJkOnAUg5-z3R6OdPwHhRAQ-gxlDDKmgtZRHIr05FJysxtPyUVq5IJVJ4USUYJZWtHtB-C6Bqpv6KljrERnLoQOUYwQhgyyd1eeqibVyzD9UdOu_srAm4HE26PdJv9xqtzUVP5-zMUyVq3l6M3--sVn_RruSf9y_pHzzdEy_u1DZL4koJdyuexlXWvH8RPfBvVtdMPhoV6tYadCpIM-BGHfvZ4ZHejhu0xiHzYcjq2-jPdXJSidDf7CSQb52ZXXjindlTpQbFfVqkLRDyerMYxlsbdF80MpLu_YlJ63O7QyEpl-LJdmve9yX7Vgx6gjWdJwD9wUf7yycPqUpevVnFiV9m-FM4nbNEeX3YJGEEfgvKbZpB3VW30YnFEXZTt0r-cwAiMYpzj4gOBeBkSXxjOkba6XCnxxODOV7LqN3myaXxlpbsDwyGRn-4WggeXLKL5noE9dQVnMeK4nr5RDt2G2Bx6k19vSUAMBPuLHrc8LkLRlaNqeJudedmEk1mlvkGuH-ISjPAY8LjV2S73tdS2s1eAHGRk1gJ_3DiS1aGcQ79mapnzgmcWsCqGpALOF8aJCE8-MaVnuadmveQ98xyc50B8EEd_yF7rs__od1t_ltYCwPnMq4pTX6fZ7xc7oMnX0MddWrl9Xc4qYCgnTVsi5UAuZbx8nHDjEiEDd_1Ph9ZTz1bsU7Yb47NXqE6IuboiwOBSWfYKWMW8eY-XQWm7GF2GUF-prxGp0RVRBhEcGIYOIbbwiCnfaFFmB><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>webrtc</tag>
      
      <tag>PeerConnection</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LinuxDebug</title>
    <link href="/2020/07/29/LinuxDebug/"/>
    <url>/2020/07/29/LinuxDebug/</url>
    
    <content type="html"><![CDATA[<h1 id="Linux-Debug"><a href="#Linux-Debug" class="headerlink" title="Linux-Debug"></a>Linux-Debug</h1><h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><pre><code class="shell"># 支持三种类型的断点# 1 普通断点 break # 2 观察断点 watch # 3 普通断点 ？？ watch value</code></pre><h2 id="coredump"><a href="#coredump" class="headerlink" title="coredump"></a>coredump</h2><p>系统默认不会生成core 文件，依赖shell 中的设置。</p><pre><code class="shell">$ ulimit -a# -c: core file size (blocks)         0 这一行表示不会有core 文件生成-t: cpu time (seconds)              unlimited-f: file size (blocks)              unlimited-d: data seg size (kbytes)          unlimited-s: stack size (kbytes)             8192-c: core file size (blocks)         0-v: address space (kbytes)          unlimited-l: locked-in-memory size (kbytes)  unlimited-u: processes                       1392-n: file descriptors                10240# 允许生成core 文件，文件大小不受限$ ulimit -c unlimited# 默认core 和可执行文件在同一目录，但可以设置# /proc/sys/kernal/core_pattern 可以格式化core 文件路径和文件名</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Security</title>
    <link href="/2020/07/27/Security/"/>
    <url>/2020/07/27/Security/</url>
    
    <content type="html"><![CDATA[<p>加解密以及ssh 登录原理备忘</p><a id="more"></a><h1 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h1><h2 id="加解密"><a href="#加解密" class="headerlink" title="加解密"></a>加解密</h2><h3 id="对称加密"><a href="#对称加密" class="headerlink" title="对称加密"></a>对称加密</h3><p>加密和解密使用同一套秘钥，加密强度高，难以被破解。随之而来的问题就是如何安全的保存秘钥，特别是客户端庞大的时候，很难保证秘钥不被泄露。</p><h3 id="非对称加密"><a href="#非对称加密" class="headerlink" title="非对称加密"></a>非对称加密</h3><p>公钥和私钥</p><p>公钥和私钥都可以加密和解密，公钥加密私钥解密，私钥加密公钥解密。</p><h4 id="中间人攻击"><a href="#中间人攻击" class="headerlink" title="中间人攻击"></a>中间人攻击</h4><p>中间人在客户端和服务端中间，让客户端误以为是真实的服务端，从而获取相关内容。</p><h4 id="数字签名和数字证书"><a href="#数字签名和数字证书" class="headerlink" title="数字签名和数字证书"></a>数字签名和数字证书</h4><p>数字签名：对data 进行hash，将hash 生成的摘要用私钥进行加密。并附在data 发给对方。对方使用公钥进行解密，获取了hash值和data，对data 进行hash 和机密的摘要进行对比。判断内容是否被篡改。</p><p>这有个问题就是公钥的分发可能被欺骗，比如我接收银行的公钥，对银行发送给我的内容进行验证。结果黑客将我保存的银行的公钥替换为黑客的公钥。这个时候我还以为我收到的是银行的公钥，这个时候黑客就可以让我误以为使用了银行的公钥进行通信。</p><p>数字证书，找一个第三方对银行的公钥进行公证，后续我使用都回去公证中心进行验证数据是否正确。</p><h2 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h2><p>ssh 主要用于计算机之间的加密登录，仅仅是一个标准的协议，具体的实现有很多种，目前使用范围最广泛的是OpenSSH。</p><pre><code class="shell">ssh user@host -p port</code></pre><p>ssh 不像https 有证书中心进行公钥的公证，那么就有可能在客户端和服务端中间存在”中间人攻击”。</p><h3 id="ssh-如何解决中间人攻击"><a href="#ssh-如何解决中间人攻击" class="headerlink" title="ssh 如何解决中间人攻击"></a>ssh 如何解决中间人攻击</h3><h4 id="口令登录"><a href="#口令登录" class="headerlink" title="口令登录"></a>口令登录</h4><p>通常在第一次登录的时候，系统会出现下面提示信息：</p><pre><code class="shell">ssh user@hostThe authenticity of host &#39;host (12.18.429.21)&#39; can&#39;t be established.RSA key fingerprint is 98:2e:d7:e0:de:9f:ac:67:28:c2:42:2d:37:16:58:4d.Are you sure you want to continue connecting (yes/no)?</code></pre><p>上面大概意思是，无法确定主机的真实性，不过知道他的公钥信息，询问你是否继续？</p><p>所谓公钥信息，就是指公钥的数字摘要(通过MD5生成的)。</p><p>很自然的一个问题就是如何知道远程主机的公钥指纹是多少？远程主机必须在自己的网站上贴出公钥指纹，以方便用户自己比较。</p><p>远程主机的公钥被接收后，会被保存在文件~/.ssh/known_hosts 中，下一次再连接该主机的时候，就会自动跳过警告部分，直接要求输入密码了。</p><h4 id="公钥登录"><a href="#公钥登录" class="headerlink" title="公钥登录"></a>公钥登录</h4><p>使用口令登录，每一次都需要输入密码，比较麻烦，ssh 提供了另外一种免去输入密码的登录方式：公钥登录</p><p>公钥登录：客户端自己生产公钥和私钥密钥对，将自己的<strong>公钥</strong>保存在远程主机上。</p><p>登录原理：远程主机向客户端发送一个随机字符串，用户用私钥加密后，再发回来。远程主机用公钥进行解密，并将机密后的字符串和随机字符串比对，如果成功，允许登录shell，不再要求密码。</p><pre><code class="shell">#远程主机的authorized_keys 文件保存了用户的公钥ssh user@host &#39;mkdir -p .ssh &amp;&amp; cat &gt;&gt; .ssh/authorized_keys&#39; &lt; ~/.ssh/id_rsa.pub</code></pre><h2 id="openssl"><a href="#openssl" class="headerlink" title="openssl"></a>openssl</h2><pre><code class="shell">#生成私钥openssl genrsa &gt; cert.key#从私钥中获取公钥openssl rsa -in cert.key -pubout -out pub.pemopenssl rsa -in cert.key -pubout -text -out pub.pem#生成证书openssl req -new -x509 -key cert.key &gt; cert.pem#生成证书的fingerprintopenssl x509 -fingerprint -sha256 -in cert.pem</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>加解密</tag>
      
      <tag>openssl</tag>
      
      <tag>ssh</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GtestGmock</title>
    <link href="/2020/05/16/GtestGmock/"/>
    <url>/2020/05/16/GtestGmock/</url>
    
    <content type="html"><![CDATA[<p>Google Gtest 单元测试框架相关整理</p><a id="more"></a><h1 id="Gtest-amp-Gmock"><a href="#Gtest-amp-Gmock" class="headerlink" title="Gtest&amp;Gmock"></a>Gtest&amp;Gmock</h1><h2 id="command"><a href="#command" class="headerlink" title="command"></a>command</h2><pre><code class="shell"># --gtest_list_tests 不会执行测试案例，而是输出一个案例的列表# --gtest_filter 对执行的测试案例进行过滤，只执行匹配的案例</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>KeyWordCode</title>
    <link href="/2020/04/16/KeyWordCode/"/>
    <url>/2020/04/16/KeyWordCode/</url>
    
    <content type="html"><![CDATA[<p>快捷键</p><a id="more"></a><h1 id="KeyWord"><a href="#KeyWord" class="headerlink" title="KeyWord"></a>KeyWord</h1><h2 id="Vscode"><a href="#Vscode" class="headerlink" title="Vscode"></a>Vscode</h2><h3 id="mac"><a href="#mac" class="headerlink" title="mac"></a>mac</h3><h4 id="多列选择"><a href="#多列选择" class="headerlink" title="多列选择"></a>多列选择</h4><pre><code class="txt">shift+option 鼠标左键</code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>GitCommand</title>
    <link href="/2020/03/16/GitCommand/"/>
    <url>/2020/03/16/GitCommand/</url>
    
    <content type="html"><![CDATA[<p>Git 个人常用命令相关整理</p><a id="more"></a><h1 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h1><h2 id="仓库操作"><a href="#仓库操作" class="headerlink" title="仓库操作"></a>仓库操作</h2><h3 id="克隆远端仓库"><a href="#克隆远端仓库" class="headerlink" title="克隆远端仓库"></a>克隆远端仓库</h3><pre><code class="shell"># 在本地生成一个目录git clone gitxxxxURL.git# 在本地生成一个指定目录git clone gitxxxxURL.git myGitDir# clone 远端仓库的指定分支git clone -b branchName gitxxxxURL.git## clone 远端仓库失败情况处理   for the fxxk wargit config --global http.proxy http://127.0.0.1:9666</code></pre><h3 id="分支推送"><a href="#分支推送" class="headerlink" title="分支推送"></a>分支推送</h3><pre><code class="shell"># 将本地当前分支推送到远端指定分支，远端分支不需要加origin 因为前面的origin 已经代表了绑定的远端仓库git push origin HEAD:specificBranch# 本地的分支强制更新远端的指定分支，远端分支的内容有可能被覆盖git push origin HEAD:specificBranch --force# 将远端指定分支删除git push origin :specificBranch</code></pre><h2 id="分支操作"><a href="#分支操作" class="headerlink" title="分支操作"></a>分支操作</h2><h3 id="跟踪远程指定分支"><a href="#跟踪远程指定分支" class="headerlink" title="跟踪远程指定分支"></a>跟踪远程指定分支</h3><p>跟踪后可以直接pull 和push，不需要指定对应的分支名</p><pre><code class="shell"># 生成一个和远端分支名一样的本地分支git checkout --track origin/branchName# 生成一个本地指定分支与远端分支关联git checkout -b localBranchName origin/branchName# 从指定的提交号中生成一个本地分支git checkout -b localBranchName commit_id</code></pre><h2 id="标签操作"><a href="#标签操作" class="headerlink" title="标签操作"></a>标签操作</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><pre><code class="shell"># 轻量级标签# 在当前分支的当前commit 上打标签git tag v1.0# 查看所有标签git tag# 给指定commit 打标签git tag v1.1 commitId# 注释标签# -a 标签名  -m 注释git tag -a v1.2 -m &quot;comment&quot; commit# 推tagsgit push origin tagname# 推所有tagsgit push origin --tags# 删除本地的taggit tag -d tagname# 删除远程的taggit push origin :refs/tags/tagname# 查看tag 内容git show tagname# 切换到指定tag 对应的代码git checkout -b localbranchname tagname</code></pre><h2 id="提交处理"><a href="#提交处理" class="headerlink" title="提交处理"></a>提交处理</h2><h3 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h3><pre><code class="shell"># 这样会生成一个新的commit-id，如果有冲突的话，还需要解决冲突 git cherry-pick commit-id # 中间是两个点.. # 提交一个范围内的commit-id 左开右闭 git cherry_pick &lt;start-commit-id&gt;..&lt;end-commit-id&gt; # 提交一个范围内的commit-id 左闭右闭 git cherry_pick &lt;start-commit-id&gt;^..&lt;end-commit-id&gt; </code></pre><h2 id="子模块"><a href="#子模块" class="headerlink" title="子模块"></a>子模块</h2><h3 id="修改某个子模块的url"><a href="#修改某个子模块的url" class="headerlink" title="修改某个子模块的url"></a>修改某个子模块的url</h3><pre><code class="shell"># 修改.gitmodules 文件中，对应模块url 信息# 使用git submodule sync 将url 更新到.git/config 中# 如果第二步骤没有成功的话，手动更新.git/config 文件</code></pre><h2 id="密钥生成"><a href="#密钥生成" class="headerlink" title="密钥生成"></a>密钥生成</h2><pre><code class="shell">ssh-keygen -t rsa -b 4096 -C &quot;handsom@guy.com&quot; </code></pre><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kity@2.0.4/dist/kity.min.js"></script><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/kityminder-core@1.4.50/dist/kityminder.core.min.js"></script><script defer="true" type="text/javascript" src="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.js"></script><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/hexo-simple-mindmap@0.2.0/dist/mindmap.min.css">]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
